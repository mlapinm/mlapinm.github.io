Cleaning string variables using SQL12m.
Это так здорово, что ты вернулся.
Теперь, когда мы знаем некоторые базовые SQL-запросы и некоторое время работали с базой данных,давайте применим это знание к чему-то еще, о чем мы говорили:подготовка и очистка данных.
Вы уже знаете, что уборка изавершение ваших данных, прежде чем вы их анализируете, является важным шагом.
Итак, в этом видео я покажу вам, как SQL может помочь вам в этом.
включая удаление дубликатов,а также четыре функции, которые помогут вам очистить строковые переменные.
Ранее мы рассмотрели, как удалить дубликаты в электронных таблицах, используяинструмент Удалить дубликаты.
В SQL,мы можем сделать то же самое, включив DISTINCT в наш оператор SELECT.
Например, скажем, компания, в которой мы работаемимеет специальную акцию для клиентов в Огайо.
Мы хотим получить идентификаторы клиентов, которые живут в Огайо.
Но некоторая информация о клиенте вводилась несколько раз.
Мы можем получить эти идентификаторы клиентов,написание SELECT customer_id FROMcustomer_data.
customer_address.
Этот запрос даст нам дубликаты, если они существуют в таблице.
Если идентификатор клиента 9080 появляется в нашей таблице три раза,наши результаты будут иметь три из этого идентификатора клиента.
Но мы этого не хотим.
Нам нужен список всех уникальных идентификаторов клиентов.
Для этого мы добавляем DISTINCT в наш оператор SELECT, написав:ВЫБЕРИТЕ DISTINCT customer_id ОТ customer_data.
customer_address.
Теперь идентификатор клиента 9080 будет отображаться в наших результатах только один раз.
Возможно, вы помните, что мы уже говорили о текстовых строках как о группе символов.
внутри ячейки, обычно состоящей из букв, цифр или того и другого.
Эти текстовые строки иногда нужно очищать.
Возможно, они были введены по-разному в разных местах вашей базы данных, итеперь они не совпадают.
В этих случаях вам нужно очистить их, прежде чем вы сможете их проанализировать.
Итак, вот несколько функций, которые вы можете использовать в SQL для обработки строковых переменных.
Вы можете узнать некоторые из этих функций, когда мы говорили оэлектронные таблицы.
Теперь пришло время увидеть, как они работают по-новому.
Получите набор данных, которым мы поделились прямо перед этим видео.
И вы можете следовать шаг за шагом со мной в оставшейся части этого видео.
Первая функция, которую я хочу вам показать, это LENGTH, с которой мы уже сталкивались.
Если мы уже знаем длину наших строковых переменных,мы можем использовать LENGTH, чтобы перепроверить согласованность наших строковых переменных.
Для некоторых баз данных этот запрос записывается как LEN, но делает то же самое.
Допустим, мы работаем с таблицей customer_address из нашегоболее ранний пример.
Мы можем убедиться, что все коды стран имеют одинаковую длину, используяLENGTH для каждой из этих строк.
Итак, чтобы написать наш SQL-запрос, давайте сначала начнем с SELECT и FROM.
Мы знаем, что наши данные поступают из таблицы customer_address.
в наборе данных customer_data.
Поэтому мы добавляем customer_data.
customer_address после предложения FROM.
Затем в SELECT мы напишем LENGTH изатем столбец, который мы хотим проверить, страна.
Чтобы напомнить себе, что это такое,мы можем пометить этот столбец в наших результатах как letter_in_country.
Итак, мы добавляем буквы AS_in_country,после ДЛИНА(страна).
В результате мы получаем список количества букв в каждой стране, перечисленных длякаждого нашего клиента.
Вроде почти все они 2-ки,что означает, что поле страны содержит только две буквы.
Но мы замечаем тот, у которого 3.
Это нехорошо.
Мы хотим, чтобы наши данные были непротиворечивыми.
Итак, давайте проверим, какие страны были неправильно указаны в нашей таблице.
Мы можем сделать это, поместив функцию LENGTH(country), котораямы создали в предложении WHERE.
Потому что мы говорим SQL отфильтровать данные, чтобы показать толькоклиентов, чья страна содержит более двух букв.
Итак, теперь мы напишем ВЫБЕРИТЕ странуОТ customer_data.
customer_addressГДЕ ДЛИНА(страна) больше 2.
Когда мы запустим этот запрос, мы теперь получим две страны, где количество букв равнобольше, чем 2, которые мы ожидаем найти.
Неправильно перечисленные страны отображаются как США вместо США.
Если бы мы создали эту таблицу, то мы могли бы обновить нашу таблицу, чтобычто эта запись отображается как США вместо США.
Но в данном случае мы не создавали эту таблицу, поэтому нам не следует ее обновлять.
Нам все еще нужно решить эту проблему, чтобы мы могли получить список всех клиентов.
в США, в том числе два, которые имеют США вместо США.
Хорошая новость заключается в том, что мы можем объяснитьэту ошибку в наших результатах, используя функцию подстроки в нашем SQL-запросе.
Чтобы написать наш SQL-запрос, начнем с написанияосновная структура, ВЫБЕРИТЕ, ОТ, ГДЕ.
Мы знаем, что наши данные поступают из таблицы customer_address.
из набора данных customer_data.
Итак, мы вводим customer_data.
customer_address,после ИЗ.
Затем мы сообщаем SQL, какие данные мы хотим, чтобы он нам предоставил.
Нам нужны все клиенты в США по их идентификаторам.
Поэтому мы вводим customer_id после SELECT.
Наконец, мы хотим, чтобы SQL отфильтровывал только американских клиентов.
Поэтому мы используем функцию подстроки после предложения WHERE.
Мы собираемся использовать функцию подстроки, чтобы получить первые две буквы каждой строки.
страна так, чтобы все они были согласованы и содержали только две буквы.
Чтобы использовать функцию подстроки,нам сначала нужно сообщить SQL столбец, где мы нашли эту ошибку, страна.
Затем мы указываем, с какой буквы начинать.
Мы хотим, чтобы SQL извлек первые две буквы, поэтомумы начинаем с первой буквы, поэтому вводим 1.
Затем нам нужно указать SQL, сколько букв, включая эту первую букву, нужно извлечь.
Так как нам нужны первые две буквы,нам нужен SQL, чтобы получить всего две буквы, поэтому мы вводим 2.
Это даст нам первые две буквы каждой страны.
Нам нужны только США, поэтому мы установим эту функцию равной США.
Когда мы запускаем этот запрос, мы получаем список всех идентификаторов клиентов клиентов.
чья страна США, включая клиентов, у которых США вместо США.
Просматривая наши результаты, кажется, что у нас есть пара дубликатов, гдеидентификатор клиента отображается несколько раз.
Помните, как мы избавляемся от дубликатов?
Мы добавляем DISTINCT перед customer_id.
Итак, теперь, когда мы запускаем этот запрос,у нас есть окончательный список идентификаторов клиентов, которые живут в США.
Наконец, давайте проверим функцию TRIM, с которой вы сталкивались ранее.
Это действительно полезно, если вы найдете записи с лишними пробелами инеобходимо устранить эти лишние пробелы для согласованности.
Например, давайте проверим столбец состояния в нашей таблице customer_address.
Так же, как мы сделали для колонки страны,мы хотим убедиться, что столбец состояния имеет постоянное количество букв.
Итак, давайте снова воспользуемся функцией LENGTH, чтобы узнать, есть ли у нас какое-либо состояние, в котором большечем две буквы, что мы и ожидали бы найти в нашей таблице данных.
Мы начнем писать наш SQL-запрос, набрав базовыйСтруктура SQL SELECT, FROM, WHERE.
Мы работаем с таблицей customer_address в наборе данных customer_data.
Итак, мы вводим customer_data.
customer_address.
после ИЗ.
Затем мы сообщаем SQL, что мы хотим, чтобы он извлек.
Мы хотим, чтобы он давал нам любое состояние, состоящее более чем из двух букв,поэтому мы вводим состояние после SELECT.
Наконец, мы хотим, чтобы SQL фильтровал состояния, содержащие более двух букв.
Это условие записывается в предложении WHERE.
Итак, мы вводим LENGTH(state) ичто оно должно быть больше 2, потому что мы хотимсостояния, в которых больше двух букв.
Мы хотим выяснить, как выглядят неправильно перечисленные состояния, если они у нас есть.
Когда мы запускаем этот запрос, мы получаем один результат.
У нас есть одно состояние, которое имеет более двух букв.
Но подождите, как может это состояние, которое кажется состоящим из двух букв,O и H для Огайо, имеют более двух букв?
Мы знаем, что символов больше двух, потому что мы использовалиДЛИНА(состояние) > 2 в предложении WHERE при фильтрации результатов.
Это означает, что дополнительные символы, которые подсчитывает SQL, должны быть пробелами.
После H должен быть пробел.
Здесь мы будем использовать функцию TRIM.
Функция TRIM удаляет все пробелы.
Итак, давайте напишем SQL-запрос, учитывающий эту ошибку.
Допустим, нам нужен список всех идентификаторов клиентов, которые живут в «Огайо» для Огайо.
Начнем с базовой структуры SQL: FROM, SELECT, WHERE.
Мы знаем, что данные поступают из customer_addressтаблица в наборе данных customer_data, поэтомумы вводим customer_data.
customer_address после FROM.
Затем мы сообщаем SQL, какие данные нам нужны.
Мы хотим, чтобы SQL предоставил нам идентификаторы клиентов, которые живут в Огайо,поэтому мы вводим customer_id после SELECT.
Поскольку мы знаем, что у нас есть несколько повторяющихся записей о клиентах,мы продолжим и введем DISTINCT перед customer_idчтобы удалить повторяющиеся идентификаторы клиентов из наших результатов.
Наконец, мы хотим, чтобы SQL предоставил нам идентификаторы клиентовклиенты, которые живут в Огайо.
Мы просим SQL отфильтровать данные, поэтому это относится к предложению WHERE.
Здесь мы будем использовать функцию TRIM.
Чтобы использовать функцию TRIM, мы сообщаем SQL столбец, который мы хотимудалите пробелы, которые в нашем случае являются состоянием.
И нам нужны только клиенты из Огайо, поэтому мы вводим = 'OH'.
Вот и все.
У нас есть все идентификаторы клиентов, которые живут в Огайо,включая этого клиента с дополнительным пространством после H.
Убедившись, что ваши строковые переменные полны и непротиворечивы, вы сэкономитевы много времени позже, избегая ошибок или просчетов.
Вот почему мы очищаем данные в первую очередь.
Надеюсь, такие функции, как длина, подстрока и обрезка, дадут ваминструменты, необходимые для начала работы со строковыми переменными в ваших собственных наборах данных.
Далее мы рассмотрим другие способы работы со строками.
и более продвинутые функции очистки.
После этого вы будете готовы начать работать с SQL самостоятельно.
До скорого.