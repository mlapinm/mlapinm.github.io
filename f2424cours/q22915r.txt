Content Based Recommendations.В последнем видео мы говорили о проблеме системы рекомендаций, где для примера у вас может быть набор фильмов, и у вас может быть набор пользователей, каждый, кто оценил некоторое подмножество фильмов. Они оценили фильмы от 1 до 5 звезд или от 0 до 5 звезд. И то, что мы хотели бы сделать, это посмотреть на этих пользователей и предсказать, как они бы оценили другие фильмы, которые они еще не оценили. В этом видео я хотел бы рассказать о нашем первом подходе к построению системы рекомендаций Этот подход называется рекомендациями на основе содержания. Вот наш набор данных от раньше и просто, чтобы напомнить вам немного нотации, Я использовал nu, чтобы обозначить количество пользователей и так что это равно 4, и нм, чтобы обозначить количество фильмов, у меня 5 фильмов. Итак, как я могу предсказать, что будут эти пропущенные значения? Предположим, что для каждого из этих фильмов у меня есть набор функций для них. В частности, предположим, что для каждый из фильмов имеет две функции, которые я собираюсь обозначить x1 и x2. Где x1 измеряет степень, в которой фильм является романтическим фильмом, а x2 измеряет степень, в которой фильм является боевым фильмом. Итак, если вы снимаете фильм «Любовь, наконец, вы знаете, что это 0,9 рейтинг по романтической шкале. Это очень романтичный фильм, но ноль в масштабе действия. Итак, почти никакого действия в этом фильме. Романс навсегда - это 1,0, много романтики и 0.01 действия. Не знаю, может, в этом фильме произошла небольшая автокатастрофа или что-то в этом роде. Так что есть немного действий. Пропуская один, давайте сделаем Мечи против каратэ, может быть, что имеет рейтинг романтики 0 и никакой романтики вообще в этом, но много действий. И нон-стоп погони за автомобилем, , может быть, снова есть крошечный кусочек романтики в этом фильме, но в основном экшен. И милые щенки любви в основном романтический фильм без действий вообще. Итак, если у нас есть такие функции, , то каждый фильм может быть представлен вектором. Давайте возьмем фильм один. Итак, давайте назовем эти фильмы 1, 2, 3, 4 и 5. Но мой первый фильм, Любовь наконец, у меня есть две мои функции, 0,9 и 0. И так это особенности x1 и x2. И добавим дополнительную функцию, как обычно, которая является моей функцией перехватчика x0 = 1. И поэтому, собрав их вместе, у меня будет функция x1. Надстрочный индекс 1 означает, что это вектор функции для моего первого фильма, а этот вектор функции равен 1. Первый 1 есть этот перехватчик. А затем мои две функции - 0.90. Так что для любви, наконец, у меня будет векторный x1, для фильм Романс навсегда у меня может быть программная функция вектора x2, и так далее, и для мечей против каратэ у меня будет другая функция вектора x надстрочный 5. Кроме того, согласованность с нашей предыдущей нотацией узла, которую мы использовали, мы собираемся установить n, чтобы быть количеством функций, не считая этого перехватчика x0. Итак n равно 2, потому что у нас есть две функции x1 и x2, захватывая степень романтики и степень действия в каждом фильме. Теперь для того, чтобы сделать прогнозы, мы делаем одно, что мы могли бы рассматривать предсказание рейтингов каждого пользователя как отдельную проблему линейной регрессии. Так конкретно, скажем, что для каждого пользователя j, мы собираемся узнать параметр вектор theta j, который в этом случае будет R3. В более общем плане, theta (j) будет R (n+1), где n - количество объектов, не считая заданного термина. И мы собираемся предсказать пользователя j как рейтинг фильм i только с внутренним продуктом между векторами параметров тета и функциями xi. Итак, давайте возьмем конкретный пример. Возьмем пользователя 1, так что это будет Алиса. И ассоциируется с Алисой будет какой-то векторный параметр theta 1. И наш второй пользователь, Боб, будет связан с другим вектором параметров theta 2. Кэрол будет связан с другим вектором параметров theta 3 и Дэйв другим вектором параметров theta 4. Итак, скажем, вы хотите сделать прогноз на , что Алиса будет думать о фильме Симпатичные щенки любви. Ну, что фильм будет иметь некоторый вектор-параметр x3 , где у нас есть, что x3 будет равен 1, который является моим термином перехвата, а затем 0.99, а затем 0. И допустим, для этого примера, предположим, что мы каким-то образом уже получили вектор-параметр theta 1 для Алисы. Мы скажем это позже точно, как мы придумали этот вектор параметров. Но давайте просто скажем, что какой-то неопределенный алгоритм обучения выучил параметр вектора theta 1 и равен этому 0,5,0. Итак, наш прогноз для этой записи будет равен тета 1, то есть вектору параметров Алисы, транспонировать x3, , который является вектором функции для фильма «Симпатичные щенки любви», номер 3. И поэтому внутреннее произведение между этими двумя векторами будет 5 раз 0.99, , что равно 4.95. И поэтому мой прогноз для этого значения здесь будет 4.95. И, возможно, это кажется разумным значением, если это действительно мой вектор-параметр theta 1. Итак, все, что мы делаем здесь, это то, что мы применяем другую копию этой линейной регрессии для каждого пользователя, и мы говорим, что Алиса имеет некоторый вектор параметров theta 1, который она использует, чтобы предсказать ее рейтинги в зависимости от того, как романтично и как действие упаковало фильм есть. И Боб, Кэрол и Дэйв, каждый из них имеет свою линейную функцию романтичность и действительность, или степень романтики и степени действия в фильме и вот как мы будем предсказывать, что их звездные рейтинги. Более формально, вот как мы можем записать проблему. Наша нотация заключается в том, что r (i, j) равно 1, если пользователь j имеет рейтинг фильма i и y (i, j) является рейтингом этого фильма, если этот рейтинг существует. То есть, если этот пользователь действительно оценил этот фильм. И на предыдущем слайде мы также определили эти, theta j, который является параметром для пользователя xi, который является вектором функции для конкретного фильма. И для каждого пользователя и каждого фильма, мы прогнозируем этот рейтинг следующим образом. Так что позвольте мне представить просто временно ввести один дополнительный бит нотации mj. Мы будем использовать mj для обозначения количества пользователей, оцененных фильмом j. Нам не нужна эта нотация только для этой строки. Теперь для того, чтобы узнать вектор параметров для theta j, ну как мы это делаем. Это в основном проблема линейной регрессии. То, что мы можем сделать, это просто выбрать векторный параметр theta j так , что прогнозируемые значения здесь максимально близки к значениям, которые мы наблюдаем в наших тренировочных наборах и значениям, которые мы наблюдали в наших данных. Так что давайте запишем это. Для того, чтобы узнать параметр вектор theta j, давайте сведем к минимуму по вектору параметра theta j суммы, и я хочу суммировать все фильмы, которые пользователь j оценил. Таким образом, мы пишем его как сумму по всем значениям i. Это a:r (i, j) равно 1. Таким образом, способ прочитать этот синтаксис суммирования - это суммирование по всем значениям i, поэтому r (i.j) равно 1. Таким образом, вы будете суммировать все фильмы, которые пользователь j оценил. И тогда я собираюсь вычислить theta j, транспонировать x i. Так что это предсказание использования рейтинга j на фильме i, - y (i, j). Так вот фактический наблюдаемый рейтинг в квадрате. А затем, позвольте мне просто разделить на количество фильмов, которые пользователь j фактически оценил. Итак, давайте просто разделим на 1 над 2m j. И так это как наименьшие квадраты регрессии. Это как линейная регрессия, где мы хотим выбрать вектор параметров theta j, чтобы минимизировать этот тип квадратного термина ошибки. И если вы хотите, вы также можете добавить в терминах иррегуляризации так плюс лямбда более 2 м, и это действительно 2mj, потому что у нас есть примеры mj. Пользователь j оценил, что много фильмов, это не похоже на то, что у нас есть столько точек данных, с которыми можно соответствовать параметрам theta j. И затем позвольте мне добавить в мой обычный термин регуляризации здесь из theta j k в квадрате. Как обычно, эта сумма от k равна 1 до n, так что здесь theta j будет a n плюс 1 мерный вектор, где в нашем раннем примере n было равно 2. Но в более широком смысле, в более общем плане n - это количество функций, которые у нас есть в фильме. И так, как обычно, мы не регулируем тету 0. Мы не регулируем условия предвзятости. Сумма от k равна 1 до n. Так что, если вы минимизируете это как функцию theta j, вы получите хорошее решение, вы получите довольно хорошую оценку вектора параметров theta j , с помощью которого можно сделать прогнозы для рейтингов фильмов пользователя j. Для рекомендуемых систем я немного изменю эту нотацию. Таким образом, чтобы упростить последующую математику, я с чтобы избавиться от этого термина mj. Так это просто константа, верно? Таким образом, я могу удалить его, не изменяя значение theta j, которое я получаю из этой оптимизации. Итак, если вы представляете, что возьмите целое уравнение, взяв все это выражение и умножив его на mj, избавьтесь от этой константы. И когда я минимизирую это, я все равно должен получить то же значение theta j, что и раньше. Так что, чтобы повторить то, что мы написали на предыдущем слайде, вот наша цель оптимизации. Чтобы узнать theta j, который является параметром для пользователя j, мы собираемся свести к минимуму theta j этих целей оптимизации. Итак, это наш обычный квадратный термин ошибки, а затем это наш термин регуляризации. Теперь, конечно, при построении системы рекомендаций, мы не просто хотим изучать параметры для одного пользователя. Мы хотим узнать параметры для всех наших пользователей. У меня есть n подстрочных u пользователей, поэтому я хочу узнать все эти параметры. Итак, то, что я собираюсь сделать, это взять эту цель оптимизации и просто добавить суммирование смеси там. Таким образом, это выражение здесь с половиной сверху это точно то же самое, что и у нас было сверху. За исключением того, что теперь вместо того, чтобы просто делать это для конкретного пользователя theta j, , я собираюсь суммировать свою цель над всеми своими пользователями и , а затем свести к минимуму эту общую цель оптимизации, минимизировать эту общую стоимость на. И когда я минимизирую это как функцию theta 1, theta 2, до theta nu, я получу отдельный вектор параметров для каждого пользователя. И затем я могу использовать это, чтобы сделать прогнозы для всех моих пользователей, для всех моих n подстрочных пользователей. Таким образом, собрав все вместе, это была наша цель оптимизации сверху. И чтобы дать этой штуке имя, я просто назову это J (theta1,..., theta nu). Итак, j, как обычно, моя цель оптимизации, которую я пытаюсь свести к минимуму. Далее, чтобы фактически сделать минимизацию, если вы должны были получить обновление градиентного спуска, это уравнения, которые вы получите. Итак, вы берете тету j, k, и вычитаете из альфа, , который является показателем обучения, умножить эти термины здесь справа. Таким образом, есть несколько разные случаи, когда k равен 0, а когда k не равен 0. Потому что наш термин регуляризации здесь регулирует только значения theta jk для k не равно 0, поэтому мы не упорядочиваем theta 0, поэтому с немного разными обновлениями, когда k равно 0, а k не равно 0. И этот термин здесь, например , является просто частичной производной по отношению к вашему параметру, , что вашей цели оптимизации. Правильно, и так это просто градиентный спуск и Я уже вычислил производные и подключил их сюда. И если это обновление градиентного спуска выглядит очень похоже на то, что мы имеем здесь для линейной регрессии Это потому, что они по существу такие же, как и линейная регрессия. Единственное незначительное различие заключается в том, что для линейной регрессии у нас есть эти 1 над m терминами, это действительно было бы 1 над mj. Но потому, что раньше, когда мы выводим цель оптимизации, мы избавились от этого, поэтому у нас нет этого 1 над m срок. Но в противном случае, это действительно некоторые из моих обучающих примеров когда-либо раз xk плюс этот термин регуляризации, плюс этот срок регуляризации способствует производной. И поэтому, если вы используете градиентный спуск, вот как вы можете минимизировать функцию стоимости j, чтобы узнать все параметры. И используя эти формулы для производной, если вы хотите, вы также можете подключить их к более продвинутому алгоритму оптимизации, как сопрягаемый градиент или LBFGS или что у вас есть. И используйте это, чтобы попытаться минимизировать функцию стоимости j, а также. Итак, надеюсь, вы теперь знаете, как вы можете применить по существу отклонение от линейной регрессии , чтобы предсказать разные рейтинги фильмов разными пользователями. Этот конкретный алгоритм называется рекомендациями на основе контента, или подход на основе контента, , потому что мы предполагаем, что у нас есть доступные для нас функции для различных фильмов. И так где функции, которые захватывают то, что такое содержание этих фильмов, о том, как романтичен этот фильм, сколько действий в этом фильме. И мы действительно используем функции контента фильмов , чтобы сделать наши прогнозы. Но для многих фильмов у нас на самом деле нет таких возможностей. Или, может быть, очень трудно получить такие функции для всех наших фильмов, для всех вещей, которые мы пытаемся продать. Итак, в следующем видео мы начнем говорить о подходе к рекомендующим системам , которые не основаны на контенте и не предполагают, что у нас есть кто-то еще , дающий нам все эти функции для всех фильмов в нашем наборе данных.