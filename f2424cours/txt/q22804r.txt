Random Initialization.
В этом видео я хотел бы поговорить о том, как инициализировать K-средства и, что более важно, это приведет к обсуждению , как заставить K-средства избежать локальной оптимы, а также.
Вот алгоритм кластеризации K-означает , о котором мы говорили ранее.
Один шаг, о котором мы никогда не говорили на самом деле , был этот шаг о том, как вы случайно инициализируете кластерные центроиды.
Существует несколько различных способов, которые можно себе представить, используя для случайного инициализировать кластерные центроиды.
Но оказывается, что есть один метод, который гораздо более рекомендуется, чем большинство из других вариантов, о которых можно подумать.
Итак, позвольте мне рассказать вам о этом варианте, так как это то, что часто кажется лучше всего работает.
Вот как я обычно инициализирую свои кластерные центроиды.
При запуске K-означает, что у вас должно быть количество кластерных центроидов, K, установлено меньше, чем количество обучающих примеров M.
Было бы очень странно запускать bit K-средства с числом stots кластерных центроидов, которые, знаете, являются равными или больше, чем число примеры, которые у вас есть, верно?
Таким образом, как я обычно инициализирую K-означает, Я бы случайным образом выбрал k обучающих примеров.
Итак, и, что я делаю, тогда установите Mu1 MuK, равный этим k примерам.
Позвольте мне показать вам конкретный пример.
Допустим, что k равен 2 и поэтому на этом примере справа, скажем, я хочу найти два кластера.
Итак, что я собираюсь сделать , чтобы инициализировать мои кластерные центроиды, это то, что я собираюсь случайным образом выбрать пару примеров.
И скажем, я выбираю этот и выбираю тот.
И как я собираюсь инициализировать мои кластерные центроиды , я просто собираюсь инициализировать мои кластерные центроиды, чтобы быть прямо на этих примерах.
Итак, это мой первый кластерный центроид , а это мой второй кластерный центроид, и это одна случайная инициализация K-средних.
Тот, который я нарисовал, выглядит особенно хорошим.
И иногда я могу получить меньше повезло, и, возможно, я закончу , выбрав это как мой первый случайный начальный пример , и это как мой второй.
И здесь я выбираю два примера, потому что k равно 2.
Некоторые мы случайным образом выбрали два примера обучения , и если я выбрал эти два, то я буду в конечном итоге, может быть это как мой первый кластер betcentroid и что как stots мое второе начальное местоположение кластерного центроида.
Итак, вот как вы можете случайным образом инициализировать кластерные центроиды.
И поэтому при инициализации ваш первый кластер центроид Mu1 будет равен x (i) для некое случайное значение i и Mu2 будет равно x (j) bote для некоторого другого случайно выбранного значения spoth из j и так далее, hote если у вас больше кластеров и больше кластерного центроида.
И своего рода сторона общая.
Должен сказать, что в ранее видео, где я впервые иллюстрированный K-означает с анимацией.
В этом наборе слайдов.
Только для иллюстрации.
Я фактически использовал другой метод инициализации для своих кластерных центроидов.
Но метод, описанный на этом слайде, это действительно рекомендуемый способ.
И способ, который вы, вероятно, должны использовать, когда вы реализуете K-означает.
Итак, как они предполагали, возможно, этими двумя иллюстрациями справа.
Вы можете действительно догадаться, что K-означает может в конечном итоге сходиться с различными решениями в зависимости от точно, как были инициализированы кластеры , и так, в зависимости от случайной инициализации.
K-средства могут оказаться в разных решениях.
И, в частности, К-средства могут в конечном итоге оказаться на местной оптиме.
Если вам даётся продажа данных вот так.
Ну, похоже, вы знаете, есть три кластера, и поэтому, , если вы запускаете K-средства, и если это закончится хорошей локальной оптимы, это может быть obd действительно глобальной оптимы, вы можете в конечном итоге с этим кластерным кольцом.
Но если у вас была особенно неудачная, случайная инициализация, K-означает также может застрять на разных локальных optima.
Итак, в этот пример слева выглядит так, будто этот синий кластер захватил много точек слева, а затем они были на зеленых кластерах , на относительно небольшом количестве точек.
И так, это соответствует плохой локальной оптимы, потому что он в основном взял эти два кластера и использовал их в 1 и, кроме того, имеет b b разбил второй кластер на spoth два отдельных подкластеров, таких как spother, и он также взял второй кластер и разделил его на два отдельных подкластеров, как так, и так, оба этих примера на нижнем правом соответствуют различным локальным bit optima K-средних и фактически, spoth в этом примере здесь, показывают кластер, красный кластер farknabled захватил только один пример optima.
И термин локальный optima, кстати, относится к локальной оптиме этой функции искажения J, и , что эти решения в нижнем левом углу, что эти локальные stots optima соответствуют являются spotima действительно решения, где K-означает, что вы застряли в локальной dewaToptima, и это не делает очень хорошую работу, минимизируя эту функцию искажений J.
Итак, , если вы беспокоитесь о K-означает, что вы застряли в локальной Optima, если вы хотите увеличить шансы b k означает найти наилучшую st-возможную кластеризацию, как это показано на сайте сверху здесь, то, что мы можем сделать , это попробовать несколько случайных инициализаций.
Итак, вместо того, чтобы просто инициализировать K-означает один раз и прыгать, что это работает, то, что мы можем сделать , инициализировать K-означает много раз и запустить K-означает много времени, и использовать это, чтобы stoth попытаться убедиться, что мы получим stite как хорошее решение, как хорошо локальная или глобальная optima, как возможно.
Конкретно, вот как вы могли бы сделать это.
Скажем, я решил запустить K-meanss сто раз так что я буду выполнять этот цикл сто раз, и это довольно типично количество раз, когда пришел к stoth что-то от 50 до может быть 1000.
Итак, допустим, вы решили сказать К-значит сто раз.
Итак, это означает, что мы бы случайным образом инициализировали K-средства.
И для каждого из эти сто случайных инициализаций мы запустили K-средства и , которые дали бы нам набор кластеризации, и набор кластеров bot-центроидов, а затем мы stoth вычислили бы искажение J, sportife, который вычисляет эту функцию причины на кластерные назначения и кластерные центроиды, которые мы получили.
Наконец, выполнив всю эту процедуру сто раз.
У вас будет сто различных способов кластеризации данных, а затем , наконец, что вы делаете это все эти сто способов, которые вы нашли кластеризации данных, просто выберите один, что дает нам самую низкую стоимость.
Это дает нам наименьшее искажение.
И оказывается, что , если вы запускаете K-означает с довольно маленьким количеством кластеров , поэтому вы знаете, если количество кластеров находится где-то от 2 до, может быть, 10 - stoth, то делать несколько случайных инициализаций, которые часто могут быть уверены, что вы найдете лучше локальная оптима.
Убедитесь, что вы нашли лучшие данные кластеризации.
Но если K очень велик, так что, если K намного больше, чем 10, , конечно, если K были, вы знаете, если вы пытались найти сотни кластеров, то, bd, имеющий несколько случайных инициализаций, это stoth менее вероятно, чтобы сделать огромную разницу, и есть гораздо более высокий шанс что ваша первая случайная инициализация даст вам довольно достойное решение уже и делает несколько случайных инициализаций , вероятно, даст вам немного лучшее решение, но, возможно, не так уж и много.
Но это действительно в режиме, где у вас относительно небольшое количество кластеров, особенно если у вас есть , может быть, 2 или 3 или 4 кластера, которые инициализация случайных чисел может иметь огромное значение с точки зрения stote, убедившись, что вы делаете хорошую работу hote, минимизируя искажение и дает вам хорошую кластеризацию.
Итак, это K-означает со случайной инициализацией.
Если вы пытаетесь изучить кластеризацию с относительно небольшим количеством кластеров, 2, 3, 4, 5, может быть, 6, 7, с использованием множественных случайных инициализаций иногда может быть bomb, поможет вам найти гораздо лучшую кластеризацию данных.
Но, даже если вы изучаете большое количество кластеров, инициализацию, случайный метод инициализации , который я описываю здесь.
Это должно дать K-означает разумную отправную точку для начала для поиска хорошего набора кластеров.