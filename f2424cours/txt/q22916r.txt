Collaborative Filtering.
В этом видео мы поговорим о подходе к построению системы рекомендаций , которая называется совместной фильтрацией.
Алгоритм, о котором мы говорим , имеет очень интересное свойство , что он делает то, что называется обучением функций и , что я имею в виду, что эта величина будет алгоритмом, который может stots начать изучать для себя, какие функции использовать.
Здесь был набор данных, который мы имели, и мы имели предположили, что для каждого фильма, кто-то пришел и сказал нам, как романтично, что bet фильм был и сколько действий было в этом фильме.
Но, как вы можете себе представить, может быть очень трудно и время трудоемким и дорогим, чтобы на самом деле попробовать , чтобы заставить кого-то, вы знаете, смотреть каждый фильм и рассказать вам, как романтично каждый фильм и stots, как действие упаковано каждый фильм, и часто вы будете canote хотят еще больше возможностей чем только эти двое.
Итак, откуда вы получаете эти функции?
Итак, давайте немного изменим проблему и предположим, что у нас есть набор данных, где мы не знаем значения этих функций.
Итак, нам дали набор данных фильмов и , как пользователи оценили их, но мы не имеем понятия, насколько романтичен каждый фильм , и у нас нет представления о том, как действие упаковано каждый фильм, так что я заменил все эти вещи вопросительными знаками.
Но теперь давайте сделаем несколько другое предположение.
Допустим, мы пошли к каждому из наших пользователей, и каждый из наших пользователей сказал нам , как сильно им нравятся романтические фильмы и сколько им нравятся экшн-фильмы.
Итак, Алиса связала ток тета 1.
Боб тета 2.
Кэрол тета 3.
Дэйв тета 4.
И предположим, что мы также используем этот и что Алиса говорит нам , что она действительно любит романтические фильмы, и поэтому есть пять там, которые abt- это множитель, связанный с X1, и позволяет stots сказать, что Алиса говорит нам, что она на самом деле не любит экшн фильмы, и поэтому есть 0 там.
И Боб говорит нам что-то похожее , так что у нас есть тета 2 здесь.
В то время как Кэрол говорит нам, что ей действительно нравятся экшн-фильмы именно поэтому есть 5 там, это множитель, связанный с X2, и помните, что есть также X0 равно 1, и давайте скажем, что Кэрол говорит нам, что она не любит романтические фильмы и так далее, аналогично для Дэйва.
Итак, давайте предположим, что каким-то образом мы можем пойти к пользователям и каждый пользователь J просто говорит нам, каково значение theta J для них.
И поэтому в основном указывает нам, насколько им нравятся разные типы фильмов.
Если мы можем получить эти параметры тета от наших пользователей, то оказывается, что это возможно, чтобы попытаться сделать вывод, какие значения x1 и x2 для каждого фильма.
Давайте посмотрим на пример.
Давайте посмотрим фильм 1.
Так что фильм 1 связал с ним вектором x1.
И вы знаете, что этот фильм называется «Любовь», но давайте не будем забывать об этом.
Давайте притворимся, что мы не знаем, о чем этот фильм, так что давайте не будем забывать название этого фильма.
Все, что мы знаем, это то, что Элис любила этот шаг.
Боб любил этот фильм.
Кэрол и Дэйв ненавидели этот фильм.
Итак, что мы можем сделать?
Ну, мы знаем из векторов , что Алиса и Боб любят романтические фильмы , потому что они сказали нам, что здесь 5.
В то время как Кэрол и Дэйв, мы знаем, что они ненавидят романтические фильмы и что они любят экшн-фильмы.
Итак , потому что это параметр векторы, которые вы знаете, использует 3 и 4, Кэрол и Дэйв, дали нам.
И так, основываясь на том, что фильм 1 любим Алиса и Боба и ненавидят Кэрол и Дэйв, мы могли бы резонно заключить, что это, вероятно, романтический фильм, obt это, вероятно, не много из боевика.
этот пример немного бит математически упрощен, но то, что мы действительно спрашиваем, какой вектор-особенности должен быть X1, так что theta 1 транспонировать bit x1 примерно равно 5, stots это рейтинг Алисы, и theta 2 транспонировать x1 также приблизительно равен 5, и theta 3 транспонирование x1 примерно равно 0, , так что это будет рейтинг Кэрол, а тета 4 транспонирование X1 примерно равно 0.
И из этого он выглядит как, вы знаете, X1 равно один, который является термином перехвата, и затем 1.
0, 0.
0, это имеет смысл, учитывая то, что мы знаем об Алисе, both Боба, Кэрол и Дэйва предпочтения фотки к фильмам и тому, как они оценили этот фильм.
И в более общем плане, мы можем спуститься по этому списку и попробовать , чтобы выяснить, что может быть разумными функциями для этих других фильмов, а также.
Давайте формализовать эту проблему изучения особенностей XI.
Предположим, что наши пользователи дали нам свои предпочтения.
Итак, предположим, что наши пользователи пришли и, вы знаете, сказал нам эти значения для theta 1 через theta NU , и мы хотим узнать вектор функции bots XI для фильма sts номер I.
То, что мы можем hete сделать, поэтому поставить следующую проблему оптимизации.
Итак, мы хотим суммировать за все индексы J для , которые у нас есть рейтинг для фильма I, потому что мы пытаемся узнать особенности для фильма I, что это векторная функция XI.
Итак, а затем то, что мы хотим сделать, это свести к минимуму эту квадрат ошибку, поэтому мы хотим выбрать особенности XI, так что, вы знаете, прогностическое значение, как пользователь J оценивает фильм, я буду похож, что мы на самом деле наблюдаем в рейтинг пользователя j на фильме I.
Так, просто, чтобы обобщить, что этот термин делает , он пытается выбрать функции XI так, что для оценки всех пользователей J, что stots оценили этот фильм, алгоритм движения также предсказывает, как этот пользователь будет иметь оценил этот фильм , который не слишком далеко, в квадратный смысл ошибки, от фактического значения , что пользователь оценил этот фильм.
Итак, это квадратный термин ошибки.
Как обычно, мы можем также добавить такой термин регуляризации, чтобы не допустить, чтобы особенности становились слишком большими.
Так вот как мы будем изучать особенности для одного конкретного фильма, но то, что мы хотим сделать, это узнать все функции для всех bw фильмов и так что я собираюсь сделать, это добавить этот cote дополнительное суммирование здесь, так что я собираюсь суммировать все Nm, N подстрочный m фильмы, и минимизировать эту цель на вершине , что суммирует все фильмы.
И если вы это сделаете, вы получите следующую проблему оптимизации.
И если вы минимизируете это, у вас есть, надеюсь, разумный набор функций для всех ваших фильмов.
Итак, собрав все вместе, что мы, алгоритм, о котором мы говорили в предыдущем видео и алгоритм, о котором мы только что говорили в этом видео.
В предыдущем видео, то, что мы показали, что вы знаете, если у вас есть набор рейтингов фильмов , так что если у вас есть данные rij и b то у вас есть yij, которые будут рейтинги фильмов.
Затем, учитывая особенности для ваших различных фильмов, мы можем узнать эти параметры theta.
Так что, если вы знали функции, вы можете узнать параметры тета для ваших разных пользователей.
И то, что мы показали ранее в этом видео, это то, что если ваши пользователи готовы дать вам параметры, то вы можете оценить особенности для различных фильмов.
Так что это своего рода проблема с курицей и яйцами.
Что будет первым?
Вы знаете, мы хотим, если мы сможем получить теты, мы можем знать Икс.
Если у нас есть Xs, мы можем узнать thetas.
И то, что вы можете сделать, а затем это на самом деле работает, то, что вы можете сделать, на самом деле случайно угадать некоторую ценность теты.
Теперь, основываясь на вашем первоначальном случайном предположении для теты, вы можете , затем идти вперед и использовать процедуру, о которой мы только что говорили , чтобы определить возможности обучения для ваших различных фильмов.
Теперь, учитывая некоторые начальные наборы функций для ваших фильмов, вы можете использовать этот первый метод , который мы говорили о в предыдущем видео, чтобы попытаться получить оценку еще лучше для ваших параметров тета.
Теперь, когда у вас есть лучшая настройка параметров theta для ваших пользователей, мы можем использовать это, возможно, даже получить лучший набор функций и так далее.
Мы можем сохранить итерацию, идя туда и обратно и оптимизируя theta, x theta, x theta, nd это на самом деле работает, и если вы это сделаете, это на самом деле приведет к тому, что ваш альбом сходится с разумным набором функций для вас фильмов и параметры для ваших разных пользователей.
Таким образом, это базовый алгоритм совместной фильтрации.
На самом деле это не окончательный алгоритм , который мы будем использовать.
В следующем видео мы сможем улучшить на этом алгоритме и сделать его немного более вычислительно эффективным.
Но, надеюсь, это дает вам ощущение того, как вы можете сформулировать проблему , где вы можете одновременно узнать параметры и одновременно изучить особенности из разных фильмов.
И для этой проблемы, для проблемы с системой recommender, это возможно только потому, что каждый пользователь оценивает несколько фильмов и, надеюсь, что каждый фильм оценивается в несколькими пользователями.
И так вы можете сделать этот процесс назад и вперед, чтобы оценить theta и x.
Итак, чтобы резюмировать, в этом видео мы видели первоначальный алгоритм совместной фильтрации.
Термин «совместная фильтрация» относится к замечанию, что когда вы запускаете этот алгоритм с большим набором пользователей , то, что все из этих пользователей эффективно делают, это своего рода «bood» коллаборативно - или сотрудничество с «stote» получить лучшие рейтинги фильмов для всех, потому что с каждый пользователь рейтинг некоторого подмножества с фильмами, каждый пользователь помогает алгоритму немного узнать лучшие функции, , а затем помоги— , оценив несколько фильмов сам, я буду помогать системе узнать лучшие функции и stoth, то эти функции могут быть использованы систему, чтобы сделать лучшие прогнозы фильмов для всех остальных.
И так есть чувство сотрудничества , когда каждый пользователь помогает системе узнать лучшие функции для общего блага.
Это это совместная фильтрация.
И, в следующем видео, что мы собираемся сделать, это взять идеи, которые разработали, и попытаться разработать лучший даже лучший алгоритм, немного лучший метод вычисления для совместной фильтрации.