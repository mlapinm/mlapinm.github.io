Matrix Vector Multiplication.В этом видео я начну говорить об умножении матриц. Мы начнем с частного случая – умножения матрицы на вектор. Начнем с примера. Вот матрица, вот вектор, и, предположим, мы хотим умножить эту матрицу на этот вектор. Что получится? Давайте я сначала решу этот пример, а затем вернусь назад и разберу процесс в подробностях. Оказывается, что результатом умножения тоже будет вектор. И я сперва вычислю его, а затем мы возвратимся и посмотрим, что именно я сделал. Чтобы получить первый элемент вектора, я возьму эти два числа, умножу их на элементы первого ряда строку матрицы A и умножить произведения. Я возьму один и умножу на один, возьму три и умножу на пять, и получится один плюс пятнадцать, то есть шестнадцать. Здесь я напишу шестнадцать. Затем для второй строки, вернее, для второго элемента я возьму вторую строку и умножу на этот вектор, будет четырежды один плюс ноль на пять, что равно четырем, поэтому здесь будет четыре. И, наконец, последний элемент вектора равен дважды один плюс один умножить на пять, то есть семь, и здесь я записываю семь. Получается, что результатом умножения матрицы 3x2 на матрицу 2x1, то есть просто на двухмерный вектор, будет матрица размерности 3 на 1. Вот почему получается матрица 3x1, иначе говоря, трехмерный вектор. Я понимаю, что проделал вычисления довольно быстро, и вы, возможно, не уверены, что сможете провести их самостоятельно, так что давайте разберем подробнее, что произошло и как устроен процесс умножения матрицы на вектор. Вот детальное описание умножения матрицы на вектор. Допустим, у меня есть матрица A, и я хочу умножить её на вектор x. Результатом этого будет какой-то вектор y. Размерность матрицы A — m на n, то есть в ней m строк и n столбцов. Умножать мы ее будем на матрицу размерности n на 1, иначе говоря, на n-мерный вектор. Оказывается, что "n" вот здесь должно совпадать с "n" вот тут. Другими словами, количество столбцов этой матрицы — вот столбцы матрицы, их здесь n — это количество должно совпадать с количеством строк здесь, должно совпадать с размерностью вектора. И тогда в результате умножения мы получим m-мерный вектор y.Другими словами, количество строк здесь, "m", совпадает с количеством строк матрицы A. Итак, как же вычисляется вектор y? Чтобы получить вектор y, мы должны вычислить его элементы y_i, умножив элементы i-й строки матрицы A на соответствующие элементы вектора x и сложив произведения. Вот что я имею в виду. Чтобы получить первый элемент вектора y, число в первой строке, сначала нам нужно взять первую строку матрицы A и умножить ее элементы на элементы вектора x. То есть я беру первое число здесь и умножаю на первое число здесь, затем беру второе число здесь и умножаю на второе число здесь, затем третье число здесь умножаю на третье число здесь и так далее, до конца строки. Теперь я складываю все эти произведения и получаю первый элемент вектора y. Чтобы получить второй элемент вектора y, вот этот, мы должны взять вторую строку матрицы A и повторить процесс. То есть мы берем вторую строку матрицы A, умножаем ее элемент за элементом на вектор x и складываем произведения. Так мы вычисляем второй элемент y. Двигаемся дальше: берем третью строку A, умножаем поэлементно на x, складываем, получаем третий элемент y и так далее, до последней строки. Вот и все. Решим ещё один пример. Вот он. Разберемся с размерностями. Размерность этой матрицы — 3 на 4. Это четырехмерный вектор — или матрица 4x1, — таким образом, в результате умножения получится трехмерный вектор. Здесь я обозначу вектор, где поместится три элемента. Давайте вычислим произведения. Чтобы получить первый элемент, я возьму четыре этих числа и умножу их на элементы вектора x. У меня получится 1 на 1 плюс 2 на 3 плюс 1 на 2 плюс 5 на 1, то есть 1 + 6 + 2 + 5, а это равно 14. Чтобы получить второй элемент, я умножу на вектор эту строку: 0 на 1 плюс... 3 на 3 плюс 0 на 2 плюс 4 на 1, что равняется 9 + 4, то есть 13. И для последнего элемента я беру последнюю строку, то есть -1 на 1, минус два... хотя по сути здесь плюс, а потом -2, умноженное на 3, плюс 0 на 2 плюс 0 на 1, и это равно минус один минус шесть, то есть -7, я записываю в вектор -7. Так? Таким образом, окончательный результат таков: вектор 14 — я просто переписываю без цветов — 13, -7.
Play video starting at :7:1 and follow transcript7:01
Как и было заявлено, в результате получилась матрица 3 на 1. Теперь вы умеете умножать матрицу на вектор. Я понимаю, что на этом слайде много действий, и если вы не вполне разобрались, откуда взялись все эти числа, остановите видео, внимательно просмотрите все шаги произведенных нами вычислений и попытайтесь понять, как появились эти 14, 13 и -7. Наконец, позвольте показать вам один ловкий прием. Представьте, что у нас есть четыре дома, и вот их площади. Пусть также у нас есть гипотеза, предсказывающая цену дома, и я хочу вычислить h(x) для каждого из этих четырех домов. Оказывается, можно быстро вычислить цены всех домов разом, если представить эту задачу как умножение матрицы на вектор. Вот как я это сделаю. Я построю матрицу таким образом: я напишу столбец из четырех единиц, а во второй столбец перенесу площади четырех домов. Вектор я построю так: он будет состоять из двух элементов, -40 и 0,25, двух коэффициентов отсюда, тета нулевого и тета первого. И теперь я перемножу эту матрицу и этот вектор. Поставлю здесь знак умножения. Что я получу? Размерность этой матрицы — 4 на 2, этой — 2 на 1, так что в результате получится четырехмерный вектор. Итак, здесь у меня будет матрица 4x1, то есть четырехмерный вектор, и я запишу четыре элемента, четыре вещественных числа. Чтобы получить первый элемент, я беру эту строку и умножаю её на вектор. Таким образом, получится -40 на 1 плюс 0,25 на 2104. Кстати, раньше я записывал 1 на -40 и 2104 на 0,25, но порядок ведь не важен, верно? -40 x 1 – то же самое, что и  1 x (-40). И этот первый элемент, конечно же, равен h(2104). То есть предсказанной цене первого дома. Что насчет второго элемента? Надеюсь, вы уже понимаете, как он у меня получится. Верно? Я беру вторую строку и умножаю на вектор. Получится -40 на 1 плюс 0,25 на 1416. И это равно h(1416). Верно?
Play video starting at :10:25 and follow transcript10:25
И так же для третьего и четвертого элементов этого четырехмерного вектора. На всякий случай уточню: это выражение, которое я только что обвел зеленой рамкой, на самом деле — число, просто одно число. И то, что я обвел пурпурной рамкой, это тоже просто число, верно? Таким образом, эта скобка справа от знака равенства — матрица размерности 4 на 1, то есть четырехмерный вектор. И суть трюка в том, что когда вы будете писать программу, выполняющую эти вычисления, — то есть, когда вы захотите предсказать цену четырех домов, значение "y" для четырех домов, — вы сможете выполнить все эти вычисления одной строкой кода. Когда мы будем говорить об Octave и других языках программирования, вы увидите, как это можно записать одной строкой кода. Запишем: наша оценка равна матрице данных, умноженной на вектор параметров. DataMatrix, матрица данных, — вот эта матрица, parameters, параметры, — этот вектор, а знак «*» обозначает умножение матрицы на вектор. И, если вы просто сделаете так, то переменная prediction (прошу прощения за почерк) при помощи всего одной строки кода — если, конечно, у вас есть библиотека для матрично-векторного умножения, — будет ссылаться на этот четырехмерный вектор, который содержит все четыре предсказанные цены. Иначе вам придется умножать матрицу на вектор как-то так: написать for i = 1 to 4... А если у вас тысяча домов, то i будет меняться от одного до тысячи, или сколько вам потребуется... А в цикле вы напишете: i-й элемент prediction равен — и проведете какие-то еще вычисления. Но оказывается, что если у вас есть много домов, если вы предсказываете цену не четырех домов, а, скажем, тысячи, то программа, написанная таким образом, на любом языке программирования, не только на Octave, но и на C++, Java, Python или каком-то еще языке высокого уровня, — в общем, программа, написанная в матричном стиле, как слева, не только проще выглядит, ведь вы пишете всего одну строку кода, а не цикл с какими-то вычислениями внутри, но и, по некоторым глубоким причинам, о которых мы узнаем позже, гораздо эффективнее вычислительно. То есть расчет прогноза цены для всех домов сразу, как в коде слева, выполняется быстрее, чем если вы пишете свой цикл for. Мы обсудим причины этого позже, когда будем говорить о векторизации и матричных вычислениях. машинном обучении это не матрицы на вектор. Мы обязательно будем использовать эту операцию, изучая линейную регрессию и другие модели. А в следующем видео мы разберем более общий случай: умножение двух матриц.