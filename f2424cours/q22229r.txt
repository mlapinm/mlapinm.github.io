Moving Data Around.В этом видео, посвященном Octave, я расскажу, как в нем манипулировать данными. Итак, если у вас есть данные для решения задачи машинного обучения, как вы будете загружать эти данные в Octave? Как вы поместите их в матрицу? Как оперировать этими матрицами? Как сохранить результат операций? Как перемещать и обрабатывать данные? Вот окно Octave, оно открыто на том месте, где мы остановились в прошлый раз. Если я напечатаю a, матрицу, которую мы создали следующей командой, то мы увидим матрицу размера 3х2. С помощью команды size вы можете узнать размер матрицы. size(A) возвращает 3 и 2. Сама команда size возвращает матрицу размера 1х2. Поэтому можно присвоить SZ=size(A), и SZ будет матрицей с первым элементом 3 и вторым элементом 2. Если набрать size(SZ). Оказывается, SZ - матрица 1х2, элементы которой отражают размерность матрицы А. Набрав size(A,1), вы узнаете одно из измерений А, число строк. size(A,2) вернет 2, число столбцов в А. Пусть у нас есть вектор V=[1 2 3 4], и мы набираем length(V). Команда вернет значение наибольшего измерения. Можно также набрать length(A), и так как А имеет размер 2х3, наибольшее измерение имеет размер 3, поэтому выводится 3. Но обычно length применяется только к векторам. Вот так *пишет формулу*. Length не применяется к матрицам во избежание путаницы. Сейчас давайте посмотрим на то, как загружаются данные и происходит поиск в файловой системе. Когда мы запускаем в Octave, мы обычно находимся в той же директории, что и Octave. Так, комманда PWD показывает текущую директорию, или папку, где находится Octave. Сейчас мы находимся не там, где нужно. Команда CD используется для перемещения по директориям. Я могу перейти в C:/Users/Ang/Desktop, это мой Рабочий Стол, и набрать LS. Это команда из Unix или Linux. LS перечислит все папки и файлы на моем Рабочем Столе.
Play video starting at :3:15 and follow transcript3:15
На моем рабочем столе сейчас два файла: featuresX и priceY. Возможно, они связаны с задачей машинного обучения, которую я хочу решить. Итак, вот мой рабочий стол. Вот featuresX, это вот это окошко, то есть вот этот файл с двумя столбцами данных. На самом деле это данные о стоимости жиья. Кажется, в этом файле данных сорок семь строк. Первый дом имеет размер 204 квадратных футов, у него 3 спальни. У второго дома 100 квадратных футов, 3 спальни и так далее. В вот этом файле priceY хранятся цены для данных в моем примере. Итак, featuresX и priceY - просто текстовые файлы с моими данными. Как мне загрузить эти данные в Octave? Я просто набираю команды load featuresX.dat, load priceY.dat и этим загружаю файлы описаний и цен. Кстати, существует множество способов сделать это. Вот такая команда: загрузим featuresX.dat, преобразовав его в строку. Ой, тут опечатка. Это равноценная команда. Тем самым я прреобразую имя файла в строку. В Octave одиночные кавычки, вот такие, обозначают работу со строками. Итак, это строка, и мы можем загрузить файл, название которого указано в строке. Команда who показывает, какие переменные я использую в среде Octave. who показывает, какие переменные сейчас есть в памяти Octave. Среди них есть featuresX и priceY, а также переменные, которые создали до этого. Я могу набрать featuresX чтобы вывести файл featuresX. И вот они, мои данные. Набираю size(featuresX) и узнаю, что это матрица 47х2. Аналогично size(priceY), в результате - вектор 47х1. Это вектор диной в 47 позиций. Это вектор-столбец, содержащий цены для моего примера. Функция who показывает текущие переменные в среде Octave. Есть также функция whos, которая выводит больше подробностей. who с s на конце также перечисляет переменные, только теперь она показывает еще и их размеры. Так, А - матрица 3х2, featuresX - матрица 47х2. priceY - матрица 47х1. То есть это просто вектор. Еще тут показано, сколько байтов памяти занимает переменная. И к какому типу она относится. Double означает число с плавающей запятой. То есть эти переменные - вещественные, с плавающей запятой. Если вы хотите удалить переменную, используйте команду clear. Сделаем clear featuresX, и снова наберем whos. Обратите внимание, что переменная featuresX пропала. Как нам сохранять данные? Давайте посмотрим. Давайте переменной v присвоим значение priceY(1:10). Этим мы записываем в v первые 10 элементов вектора Y. Напишем who или whos. Y был вектором размера 47х1. v теперь имеет размер 10х1. Потому что мы присвоили v только первые десять значений из Y. Допустим, я хочу сохранить эти данные на диск командой "save hello.mat v". Этим я запишу данные из v в файл hello.mat. Давайте попробуем. И вот файл hello.mat появился на моем рабочем столе. На моем компьютере установлен MATLAB, и иконка выглядит именно так, потому что Windows решил, что это файл MATLAB. Так что не волнуйтесь, если на вашем компьютере у этого файла другая иконка. Давайте я удалю все свои переменные. Если написать просто clear, то команда очистит все переменные рабочей среды. Видно, что рабочее пространство опустело. Если я загружу hello.mat, то я снова смогу использовать переменную v, которую я предварительно сохранил в файле hello.mat. Итак, hello.mat. Наша команда, save hello.mat v, сохранила данные в двоичном формате, в сжатом виде. Если в v хранится много данных, они будут частично сжаты. Будет занимать меньше места. Если данные нужно сохранить в виде, понятном для человека, наберите "save hello.txt v -ascii". Данные сохранятся как текст в формате ASCII. После этого у меня появится этот файл. На рабочем столе появился файл hello.txt. Вы видите сохраненные данные в текстовом виде. Вот так можно загружать и сохранять данные. Давайте поговорим об обработке данных. Давайте снова зададим А, матрицу 3х2. Займемся индексированием. Набираем A(3,2). Это указатель на 3,2-й элемент матрицы А. Обычно это обозначается как A_3,2, что означает элемент третьей
Play video starting at :9:3 and follow transcript9:03
строки и второго столбца в А, который равен 6. Можно набрать А(2,:), чтобы получить все элементы второй строки. Двоеточие означает все элементы в этой строке или столбце. Итак, А(2,:) вернет вторую строку матрицы А.Правильно? Аналогично, А(:,2) означает все элементы второго столбца в А. Я получаю числа 2 4 6. Дословно это значит: "В А, всё из второго столбца". И я получаю второй столбец А, с элементами 2, 4, 6. Есть и более сложные операции индексирования. Я просто по-быстрому приведу пример. Это используется не так часто, но все равно. A([1 3], :) Это значит: выбрать все элементы А, у которых первый индекс равен 1 или 3. Сюда подпадают все элементы из первой и третьей строки в А. Итак, я указываю матрицу А, прошу вернуть мне элементы из первой и третьей строки. Двоеточие означает, что мне нужны элементы из всех столбцов. Я получаю 1, 2, 5, 6. Хотя такие операции требуются нечасто. Посмотрим, что еще можно сделать. Есть матрица А, и эта команда возвращает её второй столбец. Это может использоваться в операции присваивания. Я могу взять второй столбец в А и присвоить ему значения 10, 11, 12. Я просто беру А и записываю во второй столбец значения 10, 11, 12. Теперь А - матрица с элементами 1, 3, 5. А в второй столбец был заменен на 10, 11, 12. Вот еще одна операция. Это выражение добавит с правой стороны еще один столбец. Итак, ой. Кажется, тут ошибка. Там должны быть точки с запятой. Теперь А выглядит так. Понятно? Надеюсь, что да. Это элементы 100, 101, 102. Это вектор-столбец. По сути, мы присвоили А предыдущее значение А. А потом добавили справа вектор-столбец. Мы составили новую матрицу из А, вот этих шести элементов слева. Мы взяли А и присоединили справа еще один столбец. Вот почему А стала вот такой матрицей 3х3. Наконец, еще один удобный прием, который я иногда использую. Это синтаксис для особых случаев. Эта команда выстраивает все элементы А в один столбец, и я получаю вектор 9х1. Все элементы А просто слились в один столбец.
Play video starting at :12:39 and follow transcript12:39
Ну и еще пара примеров.Например. Давайте я снова присвою А эти значения. И также присвою В следующие значения. Я могу создать новую матрицу С командо C=[A B]. Вот моя матрица А. Вот матрица В. Теперь я создаю С из А и В. Я просто беру эти две матрицы и соединяю их. Слева стоит матрица А. А справа стоит матрица В. Я объединил их и получил матрицу С. Можно сделать и так: C=[A; B]. Точка с запятой означает, что вторая матрица добавляется снизу. Выражение C=[A; B] также соединяет матрицы А и В, только теперь они расположены друг над другом. Матрица А сверху, В снизу, а матрица С имеет размер 6х2. То есть обычно точка с запятой означает переход на следующую строку. С образуется так: берем А, переходим на строку вниз, добавляем В. Кстати, выражение [A B] равносильно [A, B]. Есть запятая или нет, результат будет одинаков.
Play video starting at :14:10 and follow transcript14:10
Думаю, теперь вы представляете себе работу с матрицами. Вы видели команды для объединения матриц, для создания матриц большего размера. Вам нужно всего пара строк кода. В Octave можно очень быстро и удобно обрабатывать данные и сложные матрицы. Вот так можно обрабатывать данные. В следующем видео мы поговорим о том, как выполняются более сложные операции с данными. Надеюсь, теперь вы понимаете, как с помощью простых команд можно обрабатывать данные в Octave. Загружать и сохранять векторы и матрицы, загружать и сохранять данные, объединять матрицы, индексировать их и выбирать отдельные элементы.Знаю, я рассмотрел много команд. Было бы неплохо, если бы вы после этого изучили файл с записями команд, которые я писал. Изучите его. Зайдите на сайт курса и скачайте логи этого видео. Просмотрите его, самостоятельно наберите в Octave некоторые команды, поиграйте ими, чтобы понять, как они работают. Понятно, что не обязательно пытаться запомнить все эти команды. Но из этого видео вы должны были осознать, какие возможности вам даются. Когда вы позже будете писать собственные обучающиеся алгоритмы и захотите найти какую-нибудь команду, которую вроде бы видели в этом видео, откройте файл с записью лекции и поищите команду там. машинном обучении это не загрузкой данных. В следующем видео я расскажу о более продвинутой обработке данных, о вычислениях, наконец, о реализации обучающихся алгоритмов.