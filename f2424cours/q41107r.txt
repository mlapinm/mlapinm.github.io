Building a Simple HTTP Server in Python16m.
Таким образом, мы создали браузер в Python.
Пришло время создать веб-сервер в Python.
Так что помните, что у нас здесь есть браузер - это приложение, , и мы сделали это приложение Python сейчас, , который отправляет этот запрос GET.
Таким образом, мы эффективно, как я уже сказал, построил самый простой в мире браузер и отправляет запрос GET.
Сервер что-то делает, а затем отправляет ответ обратно.
И теперь мы собираемся изменить это, верно?
Мы предполагаем, что браузер существует, и это как хорошо, , потому что мы будем сервером, верно?
Итак, теперь мы рассмотрим в более подробно о том, что происходит на сервере.
И вот очень, очень простой веб-сервер.
Это несколько строк больше, чем простой веб-браузер , потому что мы должны поместить немного ошибок, проверяя с помощью некоторые попытки и исключения, хорошо?
Итак, давайте пройдем через то, что делает этот код, хорошо?
Позвольте мне снова изменить цвет на черный.
Если вы из Microsoft и вы можете сказать им , чтобы сделать ключ, чтобы изменить цвет на каракуле, Я был бы очень признателен.
О, а потом я тоже спустился на страницу.
Хорошо, так что мы собираемся вытащить еще кое-что из розетки.
Мы собираемся вытащить некоторые вещи из розетки прямо здесь.
Итак, мы собираемся сделать функцию под названием CreateServer, которую мы собираемся вызвать прямо здесь, и он собирается распечатать, как вы думаете, чтобы получить доступ к нему, а затем запустить сервер.
Теперь вся идея сервера заключается в том, что сервер проснулся, чтобы дождаться входящих соединений.
Таким образом, сервер уже существует.
Когда вы начинаете разговаривать с веб-сервером, этот сервер уже находится в этом компьютере.
Серверное программное обеспечение уже запущено, регистрирует интерес к входящим запросам.
Так вот, что мы делаем.
Когда эта программа Python запускается, он будет сидеть там и ждать в бесконечном цикле для входящих запросов.
Итак, первое, что мы делаем, мы собираемся сделать розетку.
Это очень похоже на то время, которое мы сделали.
Это конечная точка.
Это не на самом деле делает телефонный звонок.
Помнишь, я сказал, что этот звонок делает телефон.
Итак, мы говорим, что мы собираемся сделать телефон, и нам решать, будем ли мы делать звонок или принимать телефонные звонки. И это следующее, как соединение, , за исключением того, что «Я готов на порт 90 принимать телефонные звонки».
Теперь оказывается только одна программа на порту 90, которая может принимать телефонные звонки.
Так что это может взорваться.
Вы можете попробовать это сделать, я имею в виду порт 9000, , и если вы запустите это дважды, и вы можете сделать это в двух окнах на вашем компьютере, второй взорвется и скажет, что вы не можете иметь порт 9000, потому что другой кусок программного обеспечения имеет его.
Но пока бежит только один, ты уходишь.
И это часть всей этой try/кроме вещи, потому что, если вы запустите это дважды, он взорвет второй раз , потому что вы не можете получать телефонные звонки на этом сервере на порту 9000 с двумя приложениями.
Одно приложение получает телефонные звонки.
Это то, что говорит сокет слушать.
В 5 там написано: «Уважаемая операционная система, если я занят одним телефонным звонком, вы можете держать еще четыре и очередь их, а затем я вернусь и достану их для вас». Вы просите операционную систему поставить в очередь входящие вызовы.
Не говори, что ты занят, закрывай.
Если вы не сказали это прослушивание (5), если вы заняты написанием данных для телефонного звонка 1 и телефонный звонок 2 пришел , и вы не были готовы к этому прямо в тот момент, это просто отрицает телефонный звонок.
Так вот, что слушать говорит, «Дорогая операционная система держать их временно.
Я перезвоню тебе.» Вот как это работает.
И тогда, что происходит, мы идем в это принять.
Теперь это принять, «Я на телефоне, Я зарегистрировал, что мой номер и что мое расширение, и я готов забрать телефон.
Дай мне знать». Таким образом, это акцепт блокируется.
Он останавливается и просто сидит там.
И он может сидеть там вечно, буквально навсегда.
И если его никто не называет, ничего не происходит.
Следующая строка никогда не запускается до тех пор, пока вы не взорвете ее или сервер не сработает.
Так что принять является блокировкой.
И причина, по которой мы это делаем, хорошо, мы должны сначала установить телефонный звонок, верно?
Итак, следующая строка запускается только при получении телефонного звонка.
Это означает, что мы на стороне браузера , мы уже подключены.
Мы сделали телефонный звонок.
Теперь мы еще не отправили никаких данных, верно?
Теперь в этот момент, где-то там есть часть клиентского программного обеспечения, что сделал socket.
connect, и мы сделали принять и наш accept преуспел на сервере, both connect удалось, и мы готовы поговорить.
Итак, телефонный звонок был сделан.
Вопрос в том, кто собирается поздороваться?
И именно здесь протокол HTTP решает нашу проблему.
Сервер знает, что клиент должен говорить первым, , так что он просто делает прием.
Теперь вы заметите, что получение и отправка - это одна и та же функция , потому что это двусторонняя вещь.
Независимо от того, что браузер отправляет, сервер получает, и все, что сервер отправляет, браузер получает, и они могут сделать это одновременно, если они могут это выяснить.
Но обычно вы вроде как говорите, это ваша очередь слушать и моя очередь отправить, а потом я буду слушать, и обычно они вроде как идут туда и обратно.
В этом есть только один шаг.
Сервер прослушивает, получает запрос GET, отправляет данные обратно.
Итак, мы собираемся прочитать некоторые данные, и мы собираемся получить 5000 символов.
Мы получим все это.
Помните, что это одна строка, в ней есть запрос GET, и в ней есть необязательные параметры.
И мы собираемся разделить его.
Опять же, мы получили его как UTF-8.
Мы должны декодировать его для Unicode внутри Python, , а затем мы разделим его на основе новых строк, потому что запрос GET находится в одной строке, затем заголовок, заголовок, заголовок, заголовок, заголовок , а затем пустая строка в говорит нам, что мы закончили заголовки.
В этом мы просто посмотрим на эту первую строчку.
Мы ничего с этим не будем делать.
Большинство серверов на самом деле, как , смотрят на строку, чтобы выяснить, какой документ отправить.
Это очень простой сервер, он отправляет один и тот же документ независимо от того, какой URL.
Все, что мы делаем с URL, это мы печатаем его, чтобы доказать, что мы его получили, , а затем мы создаем ответ.
И в этом ответе, опять же, вернитесь к RFC 2616, , и он расскажет вам, как должен выглядеть этот ответ.
Он посылает обратно 200 ОК.
Помни, это все то, что мы видели.
Наверное, я вырезал и наклеил его из рабочей штуки.
Мы говорим, что мы отправляем его обратно в типе контента text/html, набор символов UTF-8, помню, что я говорил вам, что, есть пустая строка, а затем некоторый HTML.
HTML тело, Hello World тело.
И я бросаю эти\ r\ n, , которые являются версией новой строки сети.
И тогда вы заметите, что я кодирую его перед отправкой, , потому что это Unicode внутри Python, , и его нужно отправить как UTF-8.
Потому что, когда вы находитесь в сокете, эта вещь, которая проходит через сокет , почти всегда должна быть UTF-8.
Так что мы его кодируем.
А потом, потому что протокол так говорит, , как только мы отправим данные, мы закрываем соединение.
И помните, что клиент тоже должен был закрыть соединение.
Таким образом, мы закрываем его, он наполовину закрыт, и затем клиент получает все свои данные, получает указание, что он закрыт, знает, что он закончил все данные, , а затем клиент закрывает свою сторону.
И так есть два подвеса.
Это похоже на телефонный звонок.
Человек повесит трубку, а затем нажмите, вы вешаете трубку.
Теперь вы не можете продолжать говорить, , но вы хотите, чтобы обе стороны повесили , и это отключение - это то, что происходит.
И тогда остальная часть этого все try/за исключением различных вещей так что мы очищаем наш сокет, так что нам не нужно перезапускать наш сервер, когда наше программное обеспечение взрывается, и , так что остальная часть довольно проста.
Итак, в то время как (1), первый браузер будет говорить, а затем он отправит некоторые данные , и он вернется и подождет, пока следующий телефонный звонок, и вот что происходит.
Приходит следующий телефонный звонок, он получает запрос GET.
Он отправляет данные обратно, затем ждет еще одного телефонного звонка.
Таким образом, это бесконечный цикл, который сидит и ждет входящих телефонных звонков, и он отвечает на то же самое.
Это как вы звоните по этому номеру телефона, и он идет, и вы идете, «Я хотел бы пиццу», и там написано: «Hello World», и затем нажмите.
А потом ты позвонишь и скажешь: «Я бы хотела машину». И там написано «Привет, мир». Нажмите.
А потом ты говоришь: «Я хотел бы зарегистрироваться для этого класса.» И там написано: «Привет, мир». Нажмите.
Так что это не очень гибкий сервер, вы будете создавать гораздо более гибкие серверы, , но это тот, который я мог бы построить и поместить на одну страницу в слайд-деке.
Чтобы запустить это, если вы скачаете этот код, и это крошечный бит кода, и вы запускаете его, так что вы идете куда-то, может быть ваш ноутбук, может быть PythonAnywhere, Я не знаю, работает ли он на Python, он, вероятно, не работает на PythonAnywhere, потому что вы не можете говорить с портами.
Но давайте просто запустим это на вашем ноутбуке, и вы запустите сервер, где-нибудь получите мой образец кода или скачайте отсюда, server.py, , и это говорит вам, что это просто вывод с сервера.
И это тот момент, в который он ждёт, верно?
Он ждёт.
Сервер может ждать часами в этот момент.
Но я просто даю вам это в заявлении печати, чтобы вы могли скопировать это и поместить его в свой браузер, , чтобы вы вставляли localhost:9000 в свой браузер, , а затем сервер печатает, что он получил запрос GET для документа косой черты из этого браузера.
Это то, что послал браузер.
Я имею в виду, мы говорим от браузера Firefox к маленькому веб-серверу, который мы только что построили.
Теперь есть еще один второй запрос GET, который вы даже не знаете, потому что вы не просили его, и это потому, что браузер выполнен , чтобы запросить URL-адрес под названием favicon.
ico, чтобы он мог сделать значок, , и этот значок заканчивается на вкладке или stop где угодно в вашем браузере и так что это как значок для веб-сайта.
Таким образом, вы не просили браузер сделать это, , но это то, что делают браузеры.
И вы увидите, когда вы смотрите на свои журналы отладки , когда вы создаете материал, что это фавикон.
И так это происходит как мигает, и теперь он ждет снова, верно?
И вы можете нажать refresh или , вы можете запустить другой браузер, , и вы увидите запросы GET.
Каждый запрос GET, который вы собираетесь видеть в вашем браузере и на вашем сервере.
Так что он работает, и он работает очень хорошо , и вы можете пойти дальше и играть с ним и попробовать все это.
Итак, что мы собираемся сделать, это построить простой веб-клиент, и он будет говорить с нашим сервером.
Итак, другой веб-клиент, который мы сделали , пообщался с data.pr4e.org.
Этот поговорит сам с собой.
Так вот это.
Она почти идентична, верно?
Мы делаем телефон.
Мы собираемся подключиться к локальному хосту.
127.0.0.1 - это соединение IPv4, то, что называется loopback, прямо на тот же хост.
Мы говорим с портом 9000 , потому что именно там мы запустили наш веб-сервер, тот маленький веб-сервер, который мы только что написали.
И затем мы собираемся отправить запрос GET, действительный запрос GET, на эту вещь HTTP/1.
0, и затем две новые строки, и мы собираемся кодировать его в UTF-8, прежде чем мы отправим его.
Затем мы отправим его, а потом у нас просто есть петля, которая распечатывает все это, , а затем, когда сокет закрывается, мы ударили перерыв, а затем закрываем наш конец сокета.
Таким образом, сервер нажимает на телефон и тогда мы знаем, что мы закончили с наши данные, но мы уже распечатали их, , а затем мы вешаем трубку на нашем конце, чтобы что-то чистое все между всем остальным.
Так что это очень простой веб-клиент.
И теперь вы можете запустить веб-сервер, правильно, так же, как мы делали раньше, и вместо того, чтобы говорить в браузере, мы запускаем этот клиент.
И этот клиент получает заголовок HTTP 1 OK, его тип содержимого HTML, он получает новую строку, а затем тело, и мы закончили.
Я имею в виду, это не браузер, , но это клиент, который говорит HTTP, , и теперь вы заметите, что этот сервер сидит и ждет входящих вызовов.
Вы можете запускать это снова и снова на клиенте, запускать клиента снова и снова, верно?
И тогда вы увидите больше запросов, но в общем сервере суждено просто сидеть и ждать часами потенциально, пока клиент подключится к нему.
Затем в какой-то момент вы просто прервете этот сервер, , а затем, если вы контролируете C или взорвете это , это потерпит неудачу.
Клиент завершится неудачей, , и он завершится неудачей в этом коде подключения.
Итак, если вы хотите играть с ним, попробуйте запустить этот клиент без запуска сервера, и вы увидите, что соединение, которое является частью фактического телефонного звонка.
Это будет продолжать работать, , который делает меня телефоном на моем компьютере.
А затем connect - это звонок на удаленный компьютер, который взорвется.
И тогда, если вы хотите играть с этим, вы могли бы положить некоторые попытки и исключения вокруг него, скажем, удаленный компьютер не отвечает на порт 9000, это если вы взорвали , вы могли бы попробовать и за исключением этого.
Но я не делаю этого, потому что он не вписывается в мои слайды.
Итак, вот еще более простой веб-клиент, который мы можем использовать, и снова вы можете получить этот код из моего примера кода.
Мы не говорим на этой неделе, есть нечто более высокого уровня.
Предыдущий клиент разговаривал с сокетами, , чтобы я мог показать вам низкий уровень.
Но поскольку мы тратим так много времени на разговоры с URL-адресами, у нас есть urllib.
Поэтому я просто собираюсь использовать urllib, , и это может быть локальный хост или это может быть что-то еще.
Я просто собираюсь сделать четырехстрочный urllib вызов.
И поэтому я просто делаю urlopen того же URL-адреса.
Теперь мы работаем на уровне HTTP , потому что концепция URL не является концепцией сокета, концепция URL - это концепция HTTP.
Затем мы просто вводим в действие то, что выглядит как дескриптор файла для нас, и мы цикл через него и распечатаем все это.
Итак, мы запускаем наш сервер, и сервер вроде как говорит это и ждет.
А потом мы управляем нашим клиентом.
Это в основном попадает на наш сервер , и мы видим в окне сервера, вы должны сделать эти две вещи в двух окнах, верно?
Вы должны делать это в двух отдельных окнах.
Итак, в окне сервера он будет сидеть и ждать, , а затем в окне клиента, , когда он запускается, вы увидите, что клиент сделает запрос на сервер или взорвет, если сервер не работает.
И сервер увидит запрос GET , а затем данные вернутся клиенту.
Таким образом, вы делаете это в двух вещах, и вы можете запускать клиента снова и снова, и вы увидите каждый раз, когда вы запускаете клиент, сервер видит его, отвечает, и прочь вы идете.
И снова, наш сервер всегда говорит, «Hello World», несмотря ни на что, который восхитителен и классичен.
Это классика.
Таким образом, вы можете наблюдать, когда вы используете Django, будет способ увидеть, когда вы запускаете Django локально, и вы запускаете сервер.
Мы сделаем это позже, управляем сервером .
py, а затем вы поговорите с ним, , и вы увидите все запросы GET.
И поэтому Django, когда вы запускаете его локально, вы можете отлаживать много того, что происходит.
Вы можете видеть, как фавикон, который он запрашивает, , и это пять или шесть HTTP-запросов для создания этой маленькой веб-страницы Django.
И так это будет то, что вы научитесь делать.
И это суммирует то, что мы делаем в этом.
В начале вы смотрите на него очень просто.
Довольно скоро вы просто будете смотреть на консоль разработчика, и все это будет иметь смысл для вас.
Я хочу, чтобы вы знали , что вы можете копать настолько глубоко, насколько хотите и понять все эти протоколы , которые идут туда и обратно, хорошо?
Ура.