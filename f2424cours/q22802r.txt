K-Means Algorithm.
В задаче кластеризации нам дается немаркированный набор данных , и мы хотели бы, чтобы алгоритм автоматически hi сгруппировать данные в когерентные подмножества или в когерентные кластеры для нас.
Алгоритм K Means на самом деле является самым популярным, по наиболее широко используемым алгоритмом кластеризации , и в этом видео я хотел бы рассказать вам о том, что такое алгоритм K означает и как он работает.
K означает, что алгоритм кластеризации лучше всего иллюстрируется на картинках.
Допустим, я хочу взять немаркированный набор данных, такой как , показанный здесь, и я хочу сгруппировать данные в два кластера.
Если я запускаю алгоритм K означает кластеризацию , вот что я собираюсь сделать.
Первым шагом является случайная инициализация двух точек , называемых кластерными центроидами.
Итак, эти два креста здесь, они называются кластерными центроидами , и у меня есть два из них , потому что я хочу сгруппировать свои данные в два кластера.
K Средство является итеративным алгоритмом, и он делает две вещи.
Первый — это шаг назначения кластера , а второй — шаг центроида перемещения.
Итак, позвольте мне рассказать вам, что эти вещи означают.
Первый из двух шагов в цикле означает, это шаг назначения кластера.
Это означает, что, это проходит через каждый из примеров , каждый из этих зеленых точек , показанных здесь, и в зависимости от того, является ли он ближе к центроиду кластера, или к центроиду кластера, он собирается два кластерных центроида.
В частности, что я имею в виду под этим, это пройти через ваш набор данных и цвет каждого точек красного или синего, в зависимости от того, ближе ли это к центроиду кластера красный stots или синему centroid кластера stote, и я сделал это на этой диаграмме.
Итак, это был шаг назначения кластера.
Другая часть K означает, что в цикле K означает, что движение шаг центроида, и то, что мы собираемся сделать, это, мы собираемся взять два кластерных центроидов, то есть, красный крест и sto синий крест, и мы собираемся переместить их в среднее значение окрашены в тот же цвет.
Итак, что мы собираемся сделать, это посмотреть на все красные точки и вычислить среднее значение , на самом деле среднее значение местоположения всех красных точек, и мы собираемся переместить туда красный кластер центроид.
И то же самое для центроида синего кластера, посмотрите на все синие точки и вычислите их среднее значение , а затем переместите туда синий кластерный центроид.
Итак, позвольте мне сделать это сейчас.
Мы собираемся переместить кластерные центроиды следующим образом , и теперь я переместил их на новые средства.
Красный двигался так, как , синий двигался , а красный двигался так.
И затем мы возвращаемся к другому кластеру шаг назначения, так что мы снова собираемся посмотреть на все мои немаркированные примеры и в зависимости от того, является ли он ближе красный или синий кластерный центроид, bit я собираюсь покрасить их либо красный, либо синий.
Я собираюсь назначить каждую точку одному из двух кластерных центроидов, так что позвольте мне сделать это сейчас.
И поэтому цвета некоторых точек только что изменились.
А потом я собираюсь сделать еще один шаг центроида.
Итак, я собираюсь вычислить среднюю всех синих точек, вычислить среднюю величину всех красных точек и переместить мои кластерные центроиды вот так, и так, давайте сделаем это снова.
Позвольте мне сделать еще один шаг назначения кластера.
Так что цвет каждой точки красный или синий, исходя из того, к чему это ближе, а затем сделать еще один шаг центроида, и мы закончим.
И на самом деле, если вы продолжаете выполнять дополнительные итерации K означает отсюда, что centroids croster centroids не изменит дальше, а цвета bit точки не изменят никакого stots.
И так, это , на данный момент, K означает сходится, и это сделал довольно хорошую работу, найдя два кластера в этих данных.
Давайте напишем алгоритм K означает более формально.
K означает, что алгоритм принимает два входа.
Один - это параметр K, , который является количеством кластеров , которые вы хотите найти в данных.
Позже я скажу, как мы могли бы пойти о попытке выбрать k, но пока давайте просто скажем, что мы решили, что мы хотим, чтобы определенное количество кластеров, и мы должны сказать алгоритму, сколько stot-кластеров, мы думаем, есть в наборе данных.
А затем K означает также принимает в качестве входных данных этот вид немаркированного учебного набора только Xs и , потому что это неконтролируемое обучение, мы больше не имеем ярлыков Y.
И для неконтролируемого обучения K означает, что я собираюсь использовать соглашение, что XI является размерным вектором RN.
Вот почему мои обучающие примеры теперь являются N мерными, а N плюс одномерные векторы.
Это то, что K означает алгоритм делает.
Первый шаг заключается в том, что он случайным образом инициализирует k кластер центроиды, которые мы будем называть mu 1, mu 2, до до mu k.
И поэтому в предыдущей диаграмме, stot-кластерные центроиды соответствуют местоположению hote Красного креста hetan и местоположению синего креста.
Так что там у нас было два кластера центроидов, так что, возможно, красный крест был mu 1 , а синий крест mu 2, и в более общем плане у нас будет betk кластерных центроидов, а не только 2.
Затем внутренний цикл из k означает следующее, мы будем неоднократно делать следующее.
Сначала для каждого из моих обучающих примеров, я собираюсь , чтобы установить эту переменную CI в качестве индекса 1 по K центроида кластера, ближайшего к XI.
Итак, это был мой кластер задание шаг, где мы взяли каждый из моих примеров и окрашили его либо красным, либо синим, в зависимости от того, к какому-либо центроиду кластера, к которому он был ближе всего.
Таким образом, CI будет число от 1 до K, что говорит нам, вы знаете, это ближе к красному кресту, или это both ближе к синему кресту, stoth и другой способ написания этого stay, я собираюсь, чтобы вычислить Ci, я должен взять мой It hucks пример Xi и и flotcle I собираюсь измерить это расстояние до каждого из моих кластерных центроидов, это mu, а затем нижний регистр k, правильно, поэтому capital K - это общее количество центроидов, и я собираюсь , чтобы использовать нижний регистр k здесь, как ты индексировать в разные центроиды.
Но так, Ci собирается, я собираюсь , чтобы свести к минимуму мои значения k и найти значение K, которое минимизирует это расстояние между Xi и betкластерным центроидом, а затем, stoth вы знаете, значение k, которое сводит к минимуму это, вот что устанавливается в stark Ci.
Итак, вот еще один способ написать, что такое Ци.
Если я напишу норму между Xi минус Mu-k, , то это расстояние между мой i-й обучающий пример Xi и кластер центроида bit Mu подстрочный K, это — это stots здесь, это строчный K.
Таким образом, прописный путь K будет использоваться для обозначения общего числа кластерные центроиды, и этот строчный K число между одним и капитал К.
Я просто использую нижний регистр K для индексирования в моих различных кластерных центроидах.
Далее - нижний регистр k.
Итак это расстояние между примером и кластерным центроидом и так что я собираюсь к сделать, это найти значение K, из нижнего регистра boot k, что минимизирует это, и sto так значение centroid k, которое сводит к минимуму вы знаете, потому что это то, что я собираюсь установлен как Ci, и по соглашению здесь я написал расстояние между Xi и кластерный центроид, по соглашению люди на самом деле склонны писать это как квадрат расстояния.
Итак, мы думаем о Ci как о выборе кластерного центроида с наименьшим расстоянием в квадрате до моего обучающего примера Xi.
Но, конечно, минимизация квадратного расстояния, и минимизация расстояния, которое должно дать вам такое же значение Ci, , но мы обычно помещаем в квадрат , так же, как и соглашение о том, что люди используют для K означает.
Таким образом, это был шаг назначения кластера.
Другой в цикле из K означает, что делает шаг центроида перемещения.
И что это делает для каждого из моих кластерных центроидов, поэтому для нижнего регистра k равно 1 через K, он устанавливает Mu-k равно к среднему значению точек, назначенных кластеру.
В качестве конкретного примера допустим , что один из моих кластеров центроиды, скажем, кластерный центроид два, имеет обучающие примеры, , 1, 5, 6 и 10, присвоенные ему.
И что это означает, действительно это означает, что C1 равно C5 равно C6 равно и одинаково хорошо c10 равно, верно?
Если мы получили это из шага назначения кластера, то , что означает, что примеры 1,5,6 и 10 были назначены кластерному центроиду два.
Затем на этом шаге центроида, то, что я собираюсь сделать, это просто вычислить среднее из этих четырех вещей.
Итак, X1 плюс X5 плюс X6 плюс X10.
И теперь я собираюсь усреднять их, так что здесь я имеют четыре точки, присвоенные этому кластерному центроиду, просто возьмите одну четверть этого.
И теперь Mu2 собирается быть n-мерным вектором.
Потому что каждый из этих пример x1, x5, x6, x10 каждый из них был n-мерным вектором , и я собираюсь суммировать эти вещи и, вы знаете, разделить на четыре, потому что у меня есть четыре точки, присвоенные этому центроиду кластеров, я в конечном итоге, с моим шагом центрида движения, для моего кластерного центроида му-2.
Это приводит к перемещению mu-2 в среднем по четырем пунктам, перечисленным здесь.
Одна вещь, которую я спросил, это, ну здесь мы сказали, давайте пусть mu-k будет среднее количество очков, назначенных кластеру.
Но что, если есть кластерный центроид без баллов с нулевыми точками, назначенными ему.
В этом случае более распространенная вещь - это просто устранить этот кластерный центроид.
И если вы это сделаете, вы закончите с K минус один кластер вместо k кластеров.
Иногда, если вам действительно нужны кластеры k, то другая вещь , которую вы можете сделать, если у вас есть кластерный центроид без назначенных ему точек , вы можете просто произвольно повторно инициализировать этот кластер stot-центроид, но это более общий для того, чтобы просто устранить henstanbet-кластер, если где-то во время K означает, что он без точек , назначенных этому кластерному центроиду, и , что может произойти, хотя на практике это происходит не так часто.
Итак, это K означает Алгоритм.
Прежде чем завернуть это видео я просто хочу сказать вам об одном другом общем приложении K Means, и это к проблемам с не хорошо разделенными кластерами.
Вот что я имею в виду.
До сих пор мы представляли K Means и применяли его к данным наборам, как показано здесь, где у нас есть три довольно хорошо разделенных кластеров, и мы бы обозначили как алгоритм, чтобы найти, возможно, 3 кластера для нас.
Но оказывается, что очень часто K Means также применяется к наборам данных, которые выглядят так, где может быть не несколько очень bit хорошо разделенных кластеров.
Вот пример приложения, чтобы размер футболки.
Допустим, вы являетесь производителем футболок , который вы сделали, вы пошли к населению, которое вы хотите продать футболки, и вы собрали ряд примеров по росту и весу населения этих людей в вашей популяции, и так, ну я предполагаю высоту и вес, как правило, положительно подсвечивается, поэтому, может быть, вы получите данные , как это, вы знаете, с образец или набор примеров разных высот и вес народов.
Допустим, вы хотите размер своих футболок.
Допустим, я хочу спроектировать и продать футболки трех размеров , малых, средних и больших.
Итак, насколько большой я должен сделать свой маленький?
Насколько большой я должен быть мой средний?
И как большой я должен сделать мои большие футболки.
Один из способов сделать это было бы , чтобы запустить мой k означает кластеризация логарифма на этих данных набор, который я показал на право и, возможно, то, что K Means будет делать, это группа stots все эти точки в один stace-кластер и группировать все heto из этих точек в хэсто-второй кластер и группа все эти точки в третий кластер.
Таким образом, несмотря на то, что данные, вы знаете, перед рукой это не , похоже, что у нас было 3 хорошо разделенных кластеров, K означает, что они как бы разделяют данные bit на несколько плюсов для вас.
И то, что вы можете сделать, это посмотреть на первую популяцию людей и посмотреть на их и, знаете, посмотреть на рост и вес, и hots попытаться создать небольшую футболку stots так, чтобы она вроде как была похожа на эту первую популяцию жителей города, а затем дизайн был средний t- рубашка и дизайн большой футболки.
И это на самом деле пример сегментации рынка , где вы используете K Means для разделения рынка на 3 разных сегмента.
Таким образом, вы можете разработать продукт отдельно, который представляет собой небольшие, средние и большие футболки, , который пытается удовлетворить потребности каждого из ваших 3 отдельных подгрупп хорошо.
Итак, это алгоритм K означает.
И к настоящему времени вы должны знать, как реализовать алгоритм K означает и заставить его работать для некоторых проблем.
Но в следующих нескольких видео то, что я хочу сделать, это действительно получить более глубоко в гайки и болты K средств и , чтобы немного поговорить о том, как на самом деле заставить это работать действительно хорошо.