Sliding Windows.В предыдущем видео мы говорили о фотоконвейере OCR и о том, как это сработало. В котором мы бы взяли изображение и передать через последовательность машинного обучения компонентов для того, чтобы попытаться прочитать текст, который появляется на изображении. В этом видео мне нравится. Немного больше о том, как работает отдельные компоненты трубопровода. В частности, большая часть этого видео будет посвящена обсуждению. из того, что называется раздвижными окнами. Первый этап фильтра был Обнаружение текста, где мы смотрим на такое изображение и пытаемся найти области текста, которые появляются на этом изображении. Обнаружение текста является необычной проблемой в компьютерном зрении. Потому что в зависимости от длины текста, который вы пытаетесь найти , эти прямоугольники, которые вы пытаетесь найти , могут иметь другой аспект.
Play video starting at ::51 and follow transcript0:51
Итак, чтобы поговорить об обнаружении вещей в изображениях давайте начнем с более простого примера обнаружения пешеходов, и потом вернемся к. Идеи, которые были разработаны в обнаружении пешеходов и применить их к обнаружению текста.
Play video starting at :1:6 and follow transcript1:06
Таким образом, при обнаружении пешеходов вы хотите взять изображение, которое выглядит как это и вся идея - это отдельные пешеходы, которые появляются на изображении. Итак, есть один пешеход, которого мы нашли, есть второй один, третий четвертый, пятый. И один. Эта проблема, возможно, немного проще, чем текстовое обнаружение просто по той причине, что соотношение сторон большинства пешеходов довольно похожи. Просто используя фиксированное соотношение сторон для этих прямоугольников, которые мы пытаемся найти. Таким образом, по соотношению сторон я имею в виду соотношение между высотой и шириной этих прямоугольников.
Play video starting at :1:37 and follow transcript1:37
Они все одинаковые. для разных пешеходов, но для обнаружения текста высота и соотношение ширины различны для разных строк текста Хотя для обнаружения пешеходов, bit пешеходы могут быть разные расстояния от камеры и stay, так что высота этих прямоугольников быть разными в зависимости от того, насколько далеко они находятся. , но соотношение сторон одно и то же. Чтобы построить пешеходную систему обнаружения вот как вы можете это сделать. Предположим, что мы решили стандартизировать на этом аспекте отношение 82 на 36 , и мы могли бы сами выбрать какое-то округленное число, например 80 на 40 или что-то еще, но 82 на 36 кажется правильным.
Play video starting at :2:16 and follow transcript2:16
То, что мы будем делать, это выйти и собрать большие учебные наборы положительных и отрицательных примеров. Вот примеры 82 X 36 патчей изображений, которые содержат пешеходов, и вот примеры изображений, которых нет.
Play video starting at :2:29 and follow transcript2:29
На этом слайде я показываю 12 положительных примеров y1 и 12 примеров y0.
Play video starting at :2:36 and follow transcript2:36
В более типичном приложении для обнаружения пешеходов , у нас может быть в любом месте от 1000 примеров обучения до, возможно, 10 000 примеров обучения, или даже больше, если вы можете получить еще большие наборы тренировок. И то, что вы можете сделать, это тренировать в вашей сети или какой-то другой алгоритм обучения, чтобы взять этот вход, патч MS размера 82 по отметке 36, и классифицировать 'y', а также классифицировать этот патч изображения как содержащий пешехода или нет.
Play video starting at :3:5 and follow transcript3:05
Таким образом, это дает вам способ применения контролируемого обучения в , чтобы взять изображение патч может определить, появляется ли пешеход в этом снимке.
Play video starting at :3:14 and follow transcript3:14
Теперь, скажем, мы получим новое изображение, тестовый набор изображение, как это, и мы хотим попытаться найти изображение пешехода.
Play video starting at :3:21 and follow transcript3:21
То, что мы бы сделали, это начать , взяв прямоугольный патч этого изображения. Как показано здесь, так что это может быть 82 X 36 патч этого изображения, и запустить этот патч изображения через наш классификатор, чтобы определить, есть ли hot-пешеход в этом патче изображения, stay и, надеюсь, наш классификатор будет возвращать y равен 0 для этого патча, так как пешехода нет.
Play video starting at :3:42 and follow transcript3:42
Затем мы возьмем этот зеленый прямоугольник и немного сдвинем его , а затем запустим этот новый патч изображения через наш классификатор, чтобы решить, есть ли там пешеход.
Play video starting at :3:50 and follow transcript3:50
И сделав это, мы затем скользнем окно дальше к вправо и снова запустим этот патч через классификатор. Сумма, на которую вы смещаете прямоугольник каждый раз, когда является параметром, это иногда называется размером шага параметра , иногда также называется параметром слайда, и если вы шагаете этот пиксель за раз. Таким образом, вы можете использовать размер шага или шаг 1, который обычно выполняет лучше всего, то есть более затратоэффективным, и , поэтому, используя размер шага, например, 4 пикселя в момент времени stots, или восемь пикселей в момент времени действия или некоторое большое количество пикселов genstan может быть более распространенным, потому что вы тогда перемещая прямоугольник немного больше каждый раз. Таким образом, используя этот процесс, вы продолжаете перешагивать прямоугольник на вправо немного в момент и запускать каждый из эти патчи через классификатор, до конца концов, как вы будете скользить это окно по всему изображению, начиная с сначала строка, а затем мы идти дальше строки в изображение, вы бы затем запустить все из эти разные патчи изображения при описании некоторого размера шага или некоторые sts шаг через ваш классификатор.
Play video starting at :4:56 and follow transcript4:56
Это был довольно маленький прямоугольник , который бы только обнаруживал пешеходов одного конкретного размера. То, что мы делаем дальше, это начать смотреть на более крупные патчи изображения. Итак, теперь давайте возьмем более крупные изображения патчи, как показано здесь , и проведем их через перекрестный огонь, а также.
Play video starting at :5:13 and follow transcript5:13
И кстати, когда я говорю взять более крупный патч изображения, что я действительно имею в виду, когда вы берете патч изображения, как это, , что вы действительно делаете, это взять bit этот патч изображения, и изменить размер stoth его до 82 X 36, скажем. Таким образом, вы берете этот более крупный патч и измените его размер до быть меньшим изображением, а затем это будет изображение меньшего размера , которое вы бы пропустили через ваш классификатор, чтобы попытаться решить, есть ли пешеход в этом патче.
Play video starting at :5:37 and follow transcript5:37
И, наконец, вы можете сделать это на еще больших масштабах и запустить , что сторона Windows до конца И после того, как вы обретите весь этот процесс, надеюсь, ваш алгоритм stots обнаружит ли theres пешеходный образ появляется на изображении, так что это то, как вы тренируете heste классификатор, и затем используйте классификатор раздвижных окон или используйте детектор раздвижных окон в , чтобы найти пешеходов на изображении.
Play video starting at :6:3 and follow transcript6:03
Давайте обратимся к образцу распознавания текста и поговорим об этом этапе в нашем конвейере OCR, где наша цель — найти текстовые области в единицах.
Play video starting at :6:13 and follow transcript6:13
, похожий на обнаружение пешеходов, вы можете придумать метку тренировочный набор с положительными примерами и отрицательными примерами с примерами , соответствующими регионам, где появляется текст. Вместо того, чтобы пытаться обнаружить пешеходов, мы сейчас пытаемся обнаружить тексты. И поэтому положительные примеры собираются быть патчами изображений, где есть текст. И негативные примеры собираются быть патчами изображений, где нет текста. Обучив это, теперь мы можем применить его к новому изображению, в тестовое изображение
Play video starting at :6:43 and follow transcript6:43
Итак, вот изображение, которое мы использовали в качестве примера.
Play video starting at :6:46 and follow transcript6:46
Теперь, в последний раз, когда мы запускаем, для этого примера мы собираемся запустить раздвижные окна на только один фиксированный масштаб просто для цели иллюстрации, что означает, что я собираюсь использовать только один размер прямоугольника. Но давайте скажем, что я запускаю свой маленький классификатор скользящих окон на много маленьких патчей изображений, таких как это, если я это сделаю, то что Ill в конечном итоге это результат, как это, где белый регион stay показывает, где моя система обнаружения текста нашел staind текст, и поэтому ось эти две цифры одинаковы. Итак, здесь есть регион , конечно же, также регион здесь, так что тот факт, что этот черный здесь означает, что классификатор не думает, что он нашел какие-либо тексты stots там, в то время как сам факт, что здесь много о белых вещах, что отражает классификатор считает, что он нашел кучу текстов. вон там на изображении. То, что я сделал на этом изображении в нижнем левом углу, - это на самом деле использовать белый для шоу, где классификатор думает, что он нашел текст. И разные оттенки серого соответствуют вероятности того, что был выводим классификатором, так как оттенки серого соответствует тому, где он считает, что он мог найти текст, но имеет более низкую уверенность яркий ответ на то, является ли классификатор,
Play video starting at :7:57 and follow transcript7:57
с очень высокой вероятностью , предполагаемая вероятность , что в этом месте находятся пешеходы.
Play video starting at :8:4 and follow transcript8:04
Мы еще не совсем сделали, потому что то, что мы на самом деле хотим сделать нарисовать прямоугольники вокруг всего области, где этот текст на изображении, так что были бы, чтобы сделать еще один шаг, который мы берем выходной сигнал от классификатора и применим ему так называемый оператор экспансии.
Play video starting at :8:20 and follow transcript8:20
То, что это делает, это взять изображение здесь,
Play video starting at :8:25 and follow transcript8:25
и он берет каждый из белые капли, берет каждый из них белых регионов и расширяет этот белый регион. Математически, как вы реализуете, то есть, если вы посмотрите на изображение справа, то, что мы делаем, чтобы создать изображение справа, для каждого пикселя, который мы собираемся, чтобы спросить, является ли это расстояние от habit-белого пикселя в левом изображении. Итак, если определенный пиксель находится в пределах, скажем, пяти пикселей или десяти пикселей белого пикселя в крайнем левом изображении, тогда мы также раскрасим этот пиксель в самом правом изображении.
Play video starting at :8:56 and follow transcript8:56
И так, эффект этого заключается в том, что мы возьмем каждый из белые капли в левом изображении и расширим их бит , вырастим их немного, видя, есть ли у вас близлежащие пиксели, белые пиксели, а затем раскрашиваем эти близлежащие пиксели в белом цвете, а также. Наконец, мы почти закончили. Теперь мы можем посмотреть на это право большинство изображений и просто посмотреть на соединительные компоненты и посмотреть на как белые области и нарисовать ограничивающие рамки вокруг них. И, в частности, если мы посмотрим на все белые области, такие как этот, этот, этот один и так далее, и , если мы используем простые эвристические данные, чтобы исключить прямоугольники, чьи пропорции stoth выглядят смешно, потому что мы знаем, что коробки вокруг текста hetan должны быть намного шире, чем они высоки. И поэтому, если мы игнорируем тонкие, высокие капли, такие как этот и этот, и мы отбрасываем эти, потому что они слишком высокие и тонкие, и мы затем рисуем прямоугольники stoth вокруг тех, чьи пропорции пропорции thats hethabeth к какому соотношению выглядит для heth text , то мы можем нарисовать прямоугольники, ограничивающие коробки вокруг этого текста область, этот текстовый регион, и , что текстовый регион, соответствующий античный логотип торгового центра Лулы B, и это маленький открытый знак.
Play video starting at :10:5 and follow transcript10:05
Вон там.
Play video starting at :10:7 and follow transcript10:07
Этот пример фактически пропускает один фрагмент текста. Это очень трудно прочитать, но на самом деле есть один фрагмент текста. Это говорит, что [xx] соответствуют этому, но соотношение сторон выглядит неправильно, поэтому мы отбросили это.
Play video starting at :10:19 and follow transcript10:19
Итак, вы знаете, что это нормально на этом изображении, но в в этом конкретном примере классификатор фактически пропустил один фрагмент текста. Это очень трудно читать, потому что есть фрагмент текста , написанный на прозрачном окне.
Play video starting at :10:29 and follow transcript10:29
Это обнаружение текста
Play video starting at :10:32 and follow transcript10:32
с помощью скользящих окон. И найдя эти прямоугольники с текстом в нем, мы можем просто вырезать эти области изображения, а затем использовать более поздние этапы конвейера, чтобы попытаться удовлетворить тексты.
Play video starting at :10:45 and follow transcript10:45
Теперь, вы помните, что второй этап конвейера был сегментация символов, поэтому, учитывая изображение , как показано сверху, как мы сегментируем отдельные символы на этом изображении? Итак, что мы можем сделать, это снова использовать контролируемый алгоритм обучения с некоторым набором положительных и некоторым набором негативных примеров , то, что было both собирается сделать, это посмотреть в stoth патч изображения и попытаться staritage решить, есть ли het разделен между двумя символами, которые находятся прямо в середине
Play video starting at :11:10 and follow transcript11:10
этого совпадения изображения. Итак, для первоначальных положительных примеров. Этот первый перекрестный пример, это изображение патч выглядит так, как середина это действительно
Play video starting at :11:21 and follow transcript11:21
, середина имеет расколы между двумя символами , а второй пример, это выглядит как положительный пример, потому что если я разделил два символа, поместив строку середина, это правильно. Итак, это положительные примеры, где середина изображения представляет разрыв или раскол
Play video starting at :11:37 and follow transcript11:37
между двумя разными символами, в то время как отрицательные примеры, ну, вы должны знать, вы не хотите, чтобы разделить длину двух символов прямо в середине, и поэтому они отрицательные потому что они не представляют середину между двумя символами.
Play video starting at :11:51 and follow transcript11:51
Итак, что мы будем делать , мы будем обучать классификатор, , может быть, используя новую сеть, может быть, используя другой алгоритм обучения, чтобы попытаться классифицировать между положительными и отрицательными примерами.
Play video starting at :12:2 and follow transcript12:02
Обучив такой классификатор, мы можем запустить это на такой текст, который вытащила наша система распознавания текста
Play video starting at :12:9 and follow transcript12:09
Когда мы начинаем с взгляда на этот прямоугольник, и мы спрашиваем, «Джи, это выглядит как середина , что зеленый прямоугольник, выглядит как середина между двумя символами?». И, надеюсь, классификатор будет сказать нет, тогда мы скользнем окно, и этот является одномерным скользящим классификатором окон, потому что были both собирается скользить окно только в одной прямой линии от города слева направо, здесь нет разных строк. Здесь только один ряд. Но теперь, с классификатором в этой позиции, мы спрашиваем, ну, ли мы разделим эти два символа или поместим разбиение прямо по середине этого прямоугольника. И, надеюсь, классификатор выведет y равняется одному, в в этом случае мы решим, чтобы нарисовать строку вниз, чтобы попытаться разделить два символа.
Play video starting at :12:50 and follow transcript12:50
Затем мы скользнем окно над снова, оптический процесс, не закрыть разрыв, скользить снова, оптика говорит да, сделать разделение там и так, что dote on, и мы медленно скользить классификатор stots на право, и, надеюсь, он будет классифицировать это как еще один положительный пример и так далее. И мы сдвинем это окно вправо, запустив классификатор на каждом шаге, и , надеюсь, он расскажет нам, , знаете, какие правильные местоположения, чтобы разделить эти символы на, stots просто разделит это изображение на отдельные символы. И так это 1D скользящие окна для сегментации символов.
Play video starting at :13:25 and follow transcript13:25
Итак, вот общая фотография OCR трубы линии снова. В этом видео мы говорили о шаге обнаружения текста, где мы используем раздвижные окна для обнаружения текста. И мы также используем одномерные раздвижные окна , чтобы сделать сегментацию персонажа , чтобы сегментировать, вы знаете, это текстовое изображение в разделении символов.
Play video starting at :13:43 and follow transcript13:43
Заключительный шаг через конвейер является квалификация персонажа шаг и этот шаг вы могли бы уже быть гораздо более знакомы с с ранними видео на контролируемое обучение, где вы можете применить стандартный процесс обучения под наблюдением в пределах может быть, что-то еще для того, чтобы взять его вход, изображение как это и классифицировать какой алфавит или какие 26 символов A до Z, или, может быть, мы должны иметь 36 символов, если у вас есть числовые цифры, как stage хорошо, многоклассная проблема классификации возьмите его ввод, а изображение содержало символ и решите , что такое символ, который появляется на этом изображении? Так что это был фотоOCR
Play video starting at :14:23 and follow transcript14:23
конвейер и как вы можете использовать такие идеи, как раздвижные окна классификаторы для того, чтобы поставить эти различные компоненты для того, чтобы разработать систему OCR фото. В следующих нескольких видео мы продолжаем использовать проблему OCR фотографии, чтобы исследовать несколько интересные проблемы вокруг создания такого приложения.