1
00:00:00,530 --> 00:00:02,929
Welcome to Jeremy’s IT Lab.

2
00:00:02,929 --> 00:00:06,300
This is a free, complete course for the CCNA.

3
00:00:06,300 --> 00:00:10,170
If you like these videos, please subscribe
to follow along with the series.

4
00:00:10,170 --> 00:00:14,799
Also, please like and leave a comment, and
share the video to help spread this free series

5
00:00:14,799 --> 00:00:16,110
of videos.

6
00:00:16,110 --> 00:00:18,260
Thanks for your help.

7
00:00:18,260 --> 00:00:24,040
In this video we will  cover two very
important protocols, TCP and UDP, two Layer

8
00:00:24,040 --> 00:00:25,910
4 protocols.

9
00:00:25,910 --> 00:00:30,960
These protocols are mentioned in exam topic
1.5, which says you must be able to compare

10
00:00:30,960 --> 00:00:32,070
TCP to UDP.

11
00:00:32,070 --> 00:00:38,769
I could spend hours covering the details of
how these protocols work, but for the CCNA

12
00:00:38,769 --> 00:00:43,250
you just need a high-level understanding of
their basic characteristics and how they are

13
00:00:43,250 --> 00:00:44,300
different.

14
00:00:44,300 --> 00:00:47,940
Here’s what we’ll cover in this video.

15
00:00:47,940 --> 00:00:50,429
First up, the basics of Layer 4.

16
00:00:50,429 --> 00:00:54,949
We’ve already covered a lot regarding Layers
1, 2, and 3.

17
00:00:54,949 --> 00:01:00,190
For example, at Layer 1 we covered the most
common cable types used in networks.

18
00:01:00,190 --> 00:01:05,409
At Layer 2 we covered things like MAC addresses,
switching, and spanning tree.

19
00:01:05,409 --> 00:01:09,439
At Layer 3 we covered things like IP addresses
and routing.

20
00:01:09,439 --> 00:01:12,960
Now I think is a good time to talk about Layer
4.

21
00:01:12,960 --> 00:01:20,060
After a basic overview of Layer 4, I will
introduce TCP, the Transmission Control Protocol.

22
00:01:20,060 --> 00:01:24,189
After that, I will introduce UDP, User Datagram
Protocol.

23
00:01:24,189 --> 00:01:31,439
UDP is much simpler than TCP, and it’s easiest
to understand after learning TCP.

24
00:01:31,439 --> 00:01:32,850
Then we’ll compare the two.

25
00:01:32,850 --> 00:01:38,229
Remember, that is the exam topic, compare
TCP to UDP.

26
00:01:38,229 --> 00:01:42,549
As always, make sure to watch until the end
of the video for a bonus practice question

27
00:01:42,549 --> 00:01:47,609
from Boson ExSim, the best practice exams
you can get for the CCNA.

28
00:01:47,609 --> 00:01:51,189
If you want to get Boson ExSim, follow the
link in the video description.

29
00:01:51,189 --> 00:01:55,259
Okay, let’s get started.

30
00:01:55,259 --> 00:01:59,689
So let’s cover some basic functions of Layer
4 protocols.

31
00:01:59,689 --> 00:02:05,299
First up, Layer 4 provides transparent transfer
of data between end hosts.

32
00:02:05,299 --> 00:02:09,979
To briefly explain what that means, here’s
an image I used back in Day 3 of the course

33
00:02:09,979 --> 00:02:14,290
when I covered the OSI Model and TCP/IP Suite.

34
00:02:14,290 --> 00:02:20,300
This up here shows the network topology, with
Host A sending data to Host B. What does the

35
00:02:20,300 --> 00:02:22,390
Transport Layer do?

36
00:02:22,390 --> 00:02:27,920
It encapsulates the data with a Layer 4 header,
and then uses the services of the lower layers,

37
00:02:27,920 --> 00:02:33,770
Layers 3, 2, and 1, to deliver the data unchanged
to the destination host.

38
00:02:33,770 --> 00:02:38,019
The hosts themselves aren’t aware of the
details of the underlying network, the transfer

39
00:02:38,019 --> 00:02:42,090
of data is ‘transparent’ to them.

40
00:02:42,090 --> 00:02:47,580
Another function of Layer 4 protocols is to
provide, or not provide, various services

41
00:02:47,580 --> 00:02:48,870
to applications.

42
00:02:48,870 --> 00:02:54,459
You’ll soon see that TCP provides these
services to applications, whereas UDP does

43
00:02:54,459 --> 00:02:55,980
not.

44
00:02:55,980 --> 00:02:58,580
What are some of these services?

45
00:02:58,580 --> 00:03:01,510
One is reliable data transfer.

46
00:03:01,510 --> 00:03:06,450
That means making sure that the destination
host actually received every bit of data that

47
00:03:06,450 --> 00:03:08,739
it’s supposed to.

48
00:03:08,739 --> 00:03:12,120
Another service is error recovery.

49
00:03:12,120 --> 00:03:18,650
If an error occurs in transmission, Layer
4 can ensure the data is sent again.

50
00:03:18,650 --> 00:03:23,060
Next is data sequencing, making sure that
even if data arrives at the destination out

51
00:03:23,060 --> 00:03:28,160
of order, the end host can sequence it in
the correct order.

52
00:03:28,160 --> 00:03:33,459
One more is flow control, making sure that
the source host doesn’t send traffic faster

53
00:03:33,459 --> 00:03:36,550
than the destination host can handle.

54
00:03:36,550 --> 00:03:40,080
These are services provided by TCP but not
UDP.

55
00:03:40,080 --> 00:03:44,760
I’ll explain further later, so don’t worry
about memorizing these yet.

56
00:03:44,760 --> 00:03:50,620
Okay, one more function of Layer 4 is to provide
Layer 4 addressing.

57
00:03:50,620 --> 00:03:52,920
These addresses are called ‘port numbers’.

58
00:03:52,920 --> 00:03:58,329
Note that the word ‘port’ can also refer
to the physical interfaces you connect cables

59
00:03:58,329 --> 00:04:04,599
to on network devices, but the Layer 4 port
is a totally different meaning of the word.

60
00:04:04,599 --> 00:04:09,420
These port numbers provide a few functions,
one of them is identifying the Application

61
00:04:09,420 --> 00:04:11,959
Layer protocol that is being used.

62
00:04:11,959 --> 00:04:16,459
Another is to provide something called ‘session
multiplexing’.

63
00:04:16,459 --> 00:04:18,250
Let me explain these concepts.

64
00:04:18,250 --> 00:04:25,730
Here we have PC1, and it will access resources
from two servers over the Internet, SRV1 and

65
00:04:25,730 --> 00:04:26,730
SRV2.

66
00:04:26,730 --> 00:04:32,780
Let’s see how these ports are used to identify
the service PC1 wants to access, and to track

67
00:04:32,780 --> 00:04:36,530
sessions between PC1 and the servers.

68
00:04:36,530 --> 00:04:38,830
First of all, what is a session?

69
00:04:38,830 --> 00:04:43,820
It’s simply an exchange of data between
two or more communicating devices.

70
00:04:43,820 --> 00:04:48,990
And in your daily use of your PC, your PC
needs to be able to handle multiple communication

71
00:04:48,990 --> 00:04:51,610
sessions at once.

72
00:04:51,610 --> 00:04:57,330
Perhaps you have multiple Internet tabs open,
accessing different services over the Internet.

73
00:04:57,330 --> 00:05:02,900
You probably have multiple services running
on your computer that need Internet access.

74
00:05:02,900 --> 00:05:07,620
In PC1’s case, let’s say it is communicating
with SRV1.

75
00:05:07,620 --> 00:05:14,180
At Layer 4 it is using TCP, and it uses a
source port of 50000 and a destination port

76
00:05:14,180 --> 00:05:16,120
of 80.

77
00:05:16,120 --> 00:05:18,639
What are these ports used for?

78
00:05:18,639 --> 00:05:24,740
The destination port is very important, it
identifies the Application Layer protocol.

79
00:05:24,740 --> 00:05:32,050
For example, TCP port 80 is used for the protocol
HTTP, which is used to access websites.

80
00:05:32,050 --> 00:05:37,020
So, perhaps SRV1 is hosting a webpage that
PC1 wants to access.

81
00:05:37,020 --> 00:05:39,800
Now, how about the source port?

82
00:05:39,800 --> 00:05:45,900
It’s randomly selected by PC1, and in combination
with the destination port it helps identify

83
00:05:45,900 --> 00:05:48,550
the session.

84
00:05:48,550 --> 00:05:54,039
For example, after SRV1 receives PC1’s message
it will probably send a reply.

85
00:05:54,039 --> 00:05:59,819
In SRV1’s reply, notice that the source
and destination port numbers are reversed,

86
00:05:59,819 --> 00:06:04,690
the source port is 80 and the destination
is 50000.

87
00:06:04,690 --> 00:06:09,660
When PC1 receives this message, the source
and destination port numbers tell it that

88
00:06:09,660 --> 00:06:15,720
it’s part of the same communication session
as the message it sent earlier.

89
00:06:15,720 --> 00:06:19,620
What if PC1 opens up a separate connection
to SRV1?

90
00:06:19,620 --> 00:06:24,470
It might be using HTTP at destination port
80 again, but it’s using a different source

91
00:06:24,470 --> 00:06:25,780
port.

92
00:06:25,780 --> 00:06:31,210
SRV1’s response will use that source port
as the destination port for its response,

93
00:06:31,210 --> 00:06:35,139
so PC1 knows it’s part of that session.

94
00:06:35,139 --> 00:06:39,229
But PC1 wants to access something on SRV2
at the same time.

95
00:06:39,229 --> 00:06:46,020
It uses a TCP destination port number of 21,
and randomly selects the source port 60000.

96
00:06:46,020 --> 00:06:52,360
TCP port 21 is used for FTP, the File Transfer
Protocol.

97
00:06:52,360 --> 00:06:56,370
As the name suggests, it is used to transfer
files.

98
00:06:56,370 --> 00:07:02,910
SRV2’s reply will reverse the port numbers,
using a source port of 21 and destination

99
00:07:02,910 --> 00:07:05,400
port of 60000.

100
00:07:05,400 --> 00:07:09,580
These will tell PC1 that this communication
is part of the same session.

101
00:07:09,580 --> 00:07:15,520
Okay, I hope that gave you a basic understanding
of how ports identify the Application Layer

102
00:07:15,520 --> 00:07:22,190
protocol, such as HTTP, the Hypertext Transfer
Protocol which is used to access webpages,

103
00:07:22,190 --> 00:07:28,410
or FTP, the File Transfer Protocol which is
used, as the name says, to transfer files.

104
00:07:28,410 --> 00:07:33,160
I also showed how these numbers are used by
hosts to manage multiple communication sessions

105
00:07:33,160 --> 00:07:35,319
at once.

106
00:07:35,319 --> 00:07:41,960
The port numbers that Application Layer protocols
use are registered with the IANA, the Internet

107
00:07:41,960 --> 00:07:44,510
Assigned Numbers Authority.

108
00:07:44,510 --> 00:07:47,900
They have designated the following ranges.

109
00:07:47,900 --> 00:07:52,240
Well-known port numbers are ports 0 through
1023.

110
00:07:52,240 --> 00:08:00,389
These are used for major protocols like HTTP,
FTP, etc, and are very strictly regulated.

111
00:08:00,389 --> 00:08:07,020
Registered port numbers are in the range 1024
to 49151.

112
00:08:07,020 --> 00:08:10,400
Registration is required to use these port
numbers, although it’s not as strict as

113
00:08:10,400 --> 00:08:12,780
with the well-known port range.

114
00:08:12,780 --> 00:08:21,830
Finally, the range 49152 through 65535 is
used for ‘ephemeral’ ports, also known

115
00:08:21,830 --> 00:08:25,069
as private or dynamic ports.

116
00:08:25,069 --> 00:08:29,020
Hosts use this range when selecting the random
source port.

117
00:08:29,020 --> 00:08:33,540
Note that in the previous example, all of
the randomly selected source port numbers

118
00:08:33,540 --> 00:08:36,350
came from the ephemeral port range.

119
00:08:36,350 --> 00:08:42,770
Finally, note that port numbers are a function
of both of the main Layer 4 protocols, TCP

120
00:08:42,770 --> 00:08:44,350
and UDP.

121
00:08:44,350 --> 00:08:47,840
Next I’ll explain each of the protocols,
and you’ll see that these functions I listed

122
00:08:47,840 --> 00:08:54,420
earlier, reliable data transfer, error recovery,
data sequencing, and flow control, are provided

123
00:08:54,420 --> 00:08:58,770
by TCP and not by UDP.

124
00:08:58,770 --> 00:08:59,860
First I’ll explain TCP.

125
00:08:59,860 --> 00:09:05,200
I’ll give an overview of it’s functions,
we’ll take a brief look at the TCP header,

126
00:09:05,200 --> 00:09:08,920
and then I’ll go more in depth on a few
of its functions.

127
00:09:08,920 --> 00:09:12,580
First up, TCP is a connection-oriented protocol.

128
00:09:12,580 --> 00:09:13,730
What does that mean?

129
00:09:13,730 --> 00:09:18,260
Well, before actually sending data to the
destination host, the two hosts communicate

130
00:09:18,260 --> 00:09:20,640
to establish a connection.

131
00:09:20,640 --> 00:09:24,720
Once the connection is established, the data
exchange begins.

132
00:09:24,720 --> 00:09:28,500
The source host doesn’t just start sending
data without first communicating with the

133
00:09:28,500 --> 00:09:32,020
destination host and setting up this connection.

134
00:09:32,020 --> 00:09:36,340
Next, TCP provides reliable communication.

135
00:09:36,340 --> 00:09:37,940
How does it do that?

136
00:09:37,940 --> 00:09:42,960
The destination host must acknowledge that
it received each TCP segment.

137
00:09:42,960 --> 00:09:48,920
Remember, segment is the name of the Layer
4 PDU, like the packet at Layer 3 and frame

138
00:09:48,920 --> 00:09:50,350
at Layer 2.

139
00:09:50,350 --> 00:09:54,970
Then, if the source host doesn’t receive
an acknowledgment for a segment, it is sent

140
00:09:54,970 --> 00:09:55,970
again.

141
00:09:55,970 --> 00:09:59,810
Next, TCP provides sequencing.

142
00:09:59,810 --> 00:10:04,690
In the next slide you’ll see that there
is a sequence field in the TCP header.

143
00:10:04,690 --> 00:10:09,140
The sequence numbers in the TCP header allow
destination hosts to put segments in the correct

144
00:10:09,140 --> 00:10:12,130
order even if they arrive out of order.

145
00:10:12,130 --> 00:10:17,290
Okay, last thing for now, TCP provides flow
control.

146
00:10:17,290 --> 00:10:21,610
That means that the destination host can tell
the source host to increase or decrease the

147
00:10:21,610 --> 00:10:26,420
rate that data is sent, so that it isn’t
overwhelmed by receiving traffic faster than

148
00:10:26,420 --> 00:10:28,480
it can process it.

149
00:10:28,480 --> 00:10:35,140
Okay, now let’s take a look at the TCP header,
thanks to Wikipedia for this image.

150
00:10:35,140 --> 00:10:39,330
As you can see, there are quite a few different
fields in the TCP header, which are used to

151
00:10:39,330 --> 00:10:43,710
provide all of those different services I
listed in the previous slide.

152
00:10:43,710 --> 00:10:48,160
The good news is, you don’t have to learn
and memorize the entire header for the CCNA.

153
00:10:48,160 --> 00:10:52,660
I just want to briefly point out a few important
fields.

154
00:10:52,660 --> 00:10:56,270
First up, the source and destination port
fields.

155
00:10:56,270 --> 00:11:00,610
Note that each field is 16 bits, 2 bytes,
in length.

156
00:11:00,610 --> 00:11:09,100
That means there are a total of 65536, which
is 2 to the power of 16, available port numbers.

157
00:11:09,100 --> 00:11:13,370
The next two fields are the sequence number
and acknowledgment number.

158
00:11:13,370 --> 00:11:17,900
These two fields are used to provide sequencing
and reliable communication, I’ll show that

159
00:11:17,900 --> 00:11:20,080
in a bit more detail later.

160
00:11:20,080 --> 00:11:25,880
TCP has a series of ‘flag’ bits which
each serve a different purpose.

161
00:11:25,880 --> 00:11:31,140
I want to mention these three, ACK, SYN, and
FIN.

162
00:11:31,140 --> 00:11:35,330
These three flags are used to establish and
terminate connections.

163
00:11:35,330 --> 00:11:39,100
In the next slide I’ll explain those processes
more.

164
00:11:39,100 --> 00:11:43,500
The final field I want to point out is the
Window Size field.

165
00:11:43,500 --> 00:11:47,770
This field is used for flow control, adjusting
the rate at which data is sent.

166
00:11:47,770 --> 00:11:51,020
Okay, that’s all for the TCP header.

167
00:11:51,020 --> 00:11:54,930
You don’t have to learn every field or memorize
it, but you should be aware of the fields

168
00:11:54,930 --> 00:11:56,960
I pointed out in this slide.

169
00:11:56,960 --> 00:12:03,350
I mentioned that TCP is connection-oriented,
meaning that hosts first communicate to establish

170
00:12:03,350 --> 00:12:06,990
a connection before actually sending data.

171
00:12:06,990 --> 00:12:13,300
The method TCP uses to establish connections
is called the TCP Three-Way Handshake.

172
00:12:13,300 --> 00:12:17,660
It has that name because it involves three
messages being sent between the two hosts.

173
00:12:17,660 --> 00:12:23,950
So, let’s say PC1 wants to access a webpage
on SRV1 using HTTP.

174
00:12:23,950 --> 00:12:28,250
First, it must establish a TCP connection.

175
00:12:28,250 --> 00:12:33,940
To do so, it uses these two flags in the TCP
header that I just showed you, ACK, meaning

176
00:12:33,940 --> 00:12:37,350
acknowledgment, and SYN, meaning synchronization.

177
00:12:37,350 --> 00:12:44,380
First, PC1 will send a TCP segment to SRV1
with the SYN flag set, meaning that bit is

178
00:12:44,380 --> 00:12:46,080
set to 1.

179
00:12:46,080 --> 00:12:48,250
That is part one of the three-way handshake.

180
00:12:48,250 --> 00:12:55,990
Next, SRV1 will reply by sending a TCP segment
to PC1 with the SYN and ACK flags set.

181
00:12:55,990 --> 00:12:58,610
So both bits are set to 1.

182
00:12:58,610 --> 00:13:01,080
That is part two of the three-way handshake.

183
00:13:01,080 --> 00:13:06,670
Finally, PC1 will send a TCP segment with
the ACK bit set.

184
00:13:06,670 --> 00:13:11,150
Now the three-way handshake is complete and
the connection is established.

185
00:13:11,150 --> 00:13:15,650
The real data exchange can then begin, the
first three messages, which make up the three-way

186
00:13:15,650 --> 00:13:19,280
handshake, are just to establish a connection.

187
00:13:19,280 --> 00:13:21,550
Make sure to remember the three-way handshake.

188
00:13:21,550 --> 00:13:26,620
SYN, SYN-ACK, and then ACK.

189
00:13:26,620 --> 00:13:29,940
Now let’s talk about how TCP terminates
connections.

190
00:13:29,940 --> 00:13:34,890
This process, sometimes called the TCP ‘four-way
handshake’, is less famous than the three-way

191
00:13:34,890 --> 00:13:36,820
handshake.

192
00:13:36,820 --> 00:13:41,070
When PC1 decides that it no longer needs the
connection with SRV1 it will initiate this

193
00:13:41,070 --> 00:13:44,020
process to terminate the connection.

194
00:13:44,020 --> 00:13:48,760
The process uses these two flags in the TCP
header, FIN and ACK.

195
00:13:48,760 --> 00:13:55,020
First, PC1 sends a TCP segment to SRV1 with
the FIN flag set.

196
00:13:55,020 --> 00:13:57,700
SRV1 responds with an ACK.

197
00:13:57,700 --> 00:14:00,720
SRV1 then sends its own FIN.

198
00:14:00,720 --> 00:14:07,450
Finally, PC1 sends an ACK in response to SRV1’s
FIN, and the connection is terminated.

199
00:14:07,450 --> 00:14:11,080
Here’s the same summary I showed you before.

200
00:14:11,080 --> 00:14:15,790
So, can you see what ‘connection-oriented’
means?

201
00:14:15,790 --> 00:14:20,020
Before actually exchanging data, PC1 and SRV1
established a connection.

202
00:14:20,020 --> 00:14:25,120
Okay, now let me demonstrate how TCP uses
the sequence and acknowledgment fields of

203
00:14:25,120 --> 00:14:29,160
the header to provide reliable communication
and sequencing.

204
00:14:29,160 --> 00:14:36,140
So, let’s look at an exchange between two
PCs, PC1 and PC2.

205
00:14:36,140 --> 00:14:41,590
When PC1 sends the three-way handshake’s
SYN message, it sets a random initial sequence

206
00:14:41,590 --> 00:14:44,070
number, let’s say it sets it to 10.

207
00:14:44,070 --> 00:14:51,140
Then, when PC2 sends the SYN-ACK to PC1, it
sets its own random initial sequence number,

208
00:14:51,140 --> 00:14:53,490
for example 50.

209
00:14:53,490 --> 00:14:58,221
Not only that, it also acknowledges that it
received PC1’s segment with a sequence number

210
00:14:58,221 --> 00:15:01,940
of 10, by setting the acknowledgment field
to 11.

211
00:15:01,940 --> 00:15:03,340
Why 11?

212
00:15:03,340 --> 00:15:08,750
That’s because TCP uses something called
‘forward acknowledgment’.

213
00:15:08,750 --> 00:15:13,580
Instead of acknowledging sequence number 10
with an ack field of 10, it tells PC1 the

214
00:15:13,580 --> 00:15:17,700
sequence number of the next segment it expects
to receive.

215
00:15:17,700 --> 00:15:23,270
So continuing that process, PC1 sends the
final ACK of the three-way handshake.

216
00:15:23,270 --> 00:15:29,130
The sequence number is 11, and using forward
acknowledgment it sets a value of 51 in the

217
00:15:29,130 --> 00:15:31,040
acknowledgment field.

218
00:15:31,040 --> 00:15:37,280
PC2 replies with a sequence number of 51,
and again uses forward acknowledgment by setting

219
00:15:37,280 --> 00:15:40,790
a value of 12 in the acknowledgment field.

220
00:15:40,790 --> 00:15:43,450
Then the exchange continues, like this.

221
00:15:43,450 --> 00:15:47,100
So, what should you remember from this?

222
00:15:47,100 --> 00:15:51,940
Remember that hosts set a random initial sequence
number, and that forward acknowledgment is

223
00:15:51,940 --> 00:15:56,160
used to indicate the sequence number of the
next segment the host expects to receive.

224
00:15:56,160 --> 00:16:01,500
Okay, so now I’ve shown how the sequence
and acknowledgment fields of the TCP header

225
00:16:01,500 --> 00:16:06,470
are used to acknowledge that the host has
received each TCP segment it should receive.

226
00:16:06,470 --> 00:16:11,570
These sequence numbers also allow hosts to
know the correct order of segments, even if

227
00:16:11,570 --> 00:16:13,920
for some reason they arrive out of order.

228
00:16:13,920 --> 00:16:16,360
Now, what about this part?

229
00:16:16,360 --> 00:16:19,600
If a segment isn’t acknowledged, it is sent
again.

230
00:16:19,600 --> 00:16:23,260
I will briefly demonstrate.

231
00:16:23,260 --> 00:16:27,880
To simplify things, I will only show one set
of sequence and acknowledgment numbers.

232
00:16:27,880 --> 00:16:32,700
So, PC1 sends SRV1 a segment with sequence
number 20.

233
00:16:32,700 --> 00:16:37,220
Using forward acknowledgment, SRV1 sends Ack
21 to PC1.

234
00:16:37,220 --> 00:16:43,300
PC1 then sends Sequence number 21, but for
some reason it doesn’t reach SRV1.

235
00:16:43,300 --> 00:16:48,280
After waiting a certain amount of time with
no Ack, PC1 resends the segment.

236
00:16:48,280 --> 00:16:51,400
This is called TCP retransmission.

237
00:16:51,400 --> 00:16:57,050
This time SRV1 receives it, and sends Ack
22 to tell PC1 that it was received.

238
00:16:57,050 --> 00:17:02,730
Okay, that’s a very brief overview of how
TCP retransmits any segments that aren’t

239
00:17:02,730 --> 00:17:03,730
acknowledged.

240
00:17:03,730 --> 00:17:08,570
Finally, let me introduce how TCP provides
flow control.

241
00:17:08,570 --> 00:17:11,750
Acknowledging every single segment, no matter
what size, is inefficient.

242
00:17:11,750 --> 00:17:17,720
However, the TCP header’s window size field
allows more data to be sent before an acknowledgment

243
00:17:17,720 --> 00:17:18,720
is required.

244
00:17:18,720 --> 00:17:20,220
Here’s an example.

245
00:17:20,220 --> 00:17:26,490
A host could send three segments, with sequence
numbers 20, 21, and 22, and then an Ack is

246
00:17:26,490 --> 00:17:29,490
sent with sequence number 23.

247
00:17:29,490 --> 00:17:33,880
In addition, a ‘sliding window’ is used
to dynamically adjust how large the window

248
00:17:33,880 --> 00:17:35,600
size is.

249
00:17:35,600 --> 00:17:40,160
The window size is increased as much as possible
until a segment is dropped, then the window

250
00:17:40,160 --> 00:17:44,870
size backs down to a more reasonable level,
and slowly increases again.

251
00:17:44,870 --> 00:17:48,310
Okay, before moving on let me point out one
thing.

252
00:17:48,310 --> 00:17:52,540
In all of these examples, I used very simple
sequence numbers.

253
00:17:52,540 --> 00:17:56,761
In real situations, the sequence numbers get
much larger and do not increase by 1 with

254
00:17:56,761 --> 00:18:01,210
each message, especially when the sliding
window size gets very large.

255
00:18:01,210 --> 00:18:05,460
For the CCNA, just understand the concepts
and don’t worry about the exact numbers.

256
00:18:05,460 --> 00:18:12,180
Okay, so that was a very brief overview of
these functions that TCP provides to applications.

257
00:18:12,180 --> 00:18:16,520
It would take hours to cover all of the details,
but for the CCNA you just need to understand

258
00:18:16,520 --> 00:18:18,070
the concepts.

259
00:18:18,070 --> 00:18:21,690
The details I did show you about sequence
numbers, forward acknowledgment, etc. were

260
00:18:21,690 --> 00:18:24,320
just to help you understand the basic concepts.

261
00:18:24,320 --> 00:18:29,530
Remember, the exam topics state that you need
to be able to compare TCP to UDP, not that

262
00:18:29,530 --> 00:18:35,040
you need to understand the detailed mechanics
and operations of TCP.

263
00:18:35,040 --> 00:18:40,130
Now that you’ve seen some of what TCP provides
to communications, let’s check out UDP.

264
00:18:40,130 --> 00:18:43,740
UDP is much simpler, so I’ll sum it up in
one slide.

265
00:18:43,740 --> 00:18:46,630
UDP is not connection-oriented.

266
00:18:46,630 --> 00:18:48,660
It is connectionless.

267
00:18:48,660 --> 00:18:53,540
Unlike TCP, in UDP the sending host does not
establish a connection with the destination

268
00:18:53,540 --> 00:18:55,310
host before sending data.

269
00:18:55,310 --> 00:18:56,950
It is simply sent.

270
00:18:56,950 --> 00:19:00,750
UDP does not provide reliable communication.

271
00:19:00,750 --> 00:19:05,560
When UDP is used, acknowledgments are not
sent for received segments.

272
00:19:05,560 --> 00:19:10,540
If a segment is lost, UDP has no mechanism
to re-transmit it.

273
00:19:10,540 --> 00:19:12,930
Segments are sent ‘best-effort’.

274
00:19:12,930 --> 00:19:14,810
You might not be familiar with the term best-effort.

275
00:19:14,810 --> 00:19:20,620
Basically, it means UDP provides no guarantee
of delivery like TCP.

276
00:19:20,620 --> 00:19:24,850
It sends it, it makes the effort, but it doesn’t
provide any guarantees.

277
00:19:24,850 --> 00:19:28,150
UDP does not provide sequencing.

278
00:19:28,150 --> 00:19:32,220
Unlike TCP, UDP has no sequence field in its
header.

279
00:19:32,220 --> 00:19:36,510
If segments arrive out of order, UDP has no
mechanism to put them back in order.

280
00:19:36,510 --> 00:19:40,120
Finally, UDP does not provide flow control.

281
00:19:40,120 --> 00:19:44,330
It has no mechanism like TCP’s window size
to control the flow of data.

282
00:19:44,330 --> 00:19:47,480
Let’s take a look at the UDP header.

283
00:19:47,480 --> 00:19:49,530
, thanks again to Wikipedia for the image.

284
00:19:49,530 --> 00:19:50,890
That’s it.

285
00:19:50,890 --> 00:19:52,259
Four fields.

286
00:19:52,259 --> 00:19:57,310
Source and destination port numbers, a length
field indicating the length of the segment,

287
00:19:57,310 --> 00:20:00,820
and a checksum so the receiving host can check
for errors.

288
00:20:00,820 --> 00:20:05,810
In the next slide let’s compare TCP and
UDP.

289
00:20:05,810 --> 00:20:08,850
First up, here are the two headers for comparison.

290
00:20:08,850 --> 00:20:12,980
All of the additional fields that TCP has
allow it to provide those additional functions

291
00:20:12,980 --> 00:20:16,200
like sequencing and error recovery.

292
00:20:16,200 --> 00:20:23,550
So, in which cases would TCP be used, and
in which cases would UDP be used?

293
00:20:23,550 --> 00:20:29,420
TCP provides more features than UDP, but at
the cost of additional overhead because of

294
00:20:29,420 --> 00:20:31,220
the larger header.

295
00:20:31,220 --> 00:20:36,600
In addition, acknowledgments and retransmissions
can slow down the transfer of data  .

296
00:20:36,600 --> 00:20:43,130
For applications that require reliable communications,
for example downloading a file, TCP is preferred.

297
00:20:43,130 --> 00:20:46,420
You wouldn’t want to download a PDF file
with a page missing.

298
00:20:46,420 --> 00:20:49,430
You want to make sure you get the whole file.

299
00:20:49,430 --> 00:20:55,010
On the other hand, for applications like real-time
voice and video, for example voice over IP

300
00:20:55,010 --> 00:20:59,990
phone calls, Zoom, Skype, etc, UDP is preferred.

301
00:20:59,990 --> 00:21:04,380
These applications are very delay-sensitive,
you don’t want the overhead of TCP slowing

302
00:21:04,380 --> 00:21:06,300
it down.

303
00:21:06,300 --> 00:21:10,800
One thing to note is that there are some applications
that use UDP, but provide reliability and

304
00:21:10,800 --> 00:21:13,400
such within the application itself.

305
00:21:13,400 --> 00:21:18,070
TFTP, the Trivial File Transfer Protocol,
is such an example.

306
00:21:18,070 --> 00:21:20,430
I’ll cover it later in the course.

307
00:21:20,430 --> 00:21:23,520
Also, think about a Skype call.

308
00:21:23,520 --> 00:21:28,200
If you’re talking to someone over Skype
and the audio cuts out for a few seconds,

309
00:21:28,200 --> 00:21:31,100
you can simply ask the other person to repeat
what they said.

310
00:21:31,100 --> 00:21:34,720
In effect, you are asking for a ‘retransmission’.

311
00:21:34,720 --> 00:21:40,750
Finally, there are some applications that
use both TCP &amp; UDP, depending on the situation.

312
00:21:40,750 --> 00:21:45,410
DNS, the Domain Name System, is an example.

313
00:21:45,410 --> 00:21:50,540
Here’s a chart summarizing the differences
between TCP and UDP.

314
00:21:50,540 --> 00:21:56,400
But don’t forget, both TCP and UDP provide
Layer 4 addressing in the form of port numbers.

315
00:21:56,400 --> 00:22:02,110
These port numbers identify Application Layer
protocols and allow for session multiplexing.

316
00:22:02,110 --> 00:22:07,140
They are both Layer 4 protocols, so they both
provide these essential functions.

317
00:22:07,140 --> 00:22:12,230
Finally, I will list some important well-known
port numbers you should know.

318
00:22:12,230 --> 00:22:18,020
We haven’t really covered any of these Application
Layer protocols in the course yet, but I recommend

319
00:22:18,020 --> 00:22:21,090
taking the time to memorize the port numbers
now.

320
00:22:21,090 --> 00:22:25,150
I will provide flashcards in the flashcard
deck for today’s lecture.

321
00:22:25,150 --> 00:22:28,720
I will, however, mention the port numbers
again when I cover these protocols later in

322
00:22:28,720 --> 00:22:32,210
the course, so if you prefer you can learn
them individually then.

323
00:22:32,210 --> 00:22:34,480
Here’s the list.

324
00:22:34,480 --> 00:22:39,860
First up, FTP, the File Transfer Protocol,
uses TCP ports 20 and 21.

325
00:22:39,860 --> 00:22:45,800
SSH, Secure Shell, which is commonly used
to connect to the CLI of routers and switches,

326
00:22:45,800 --> 00:22:48,070
uses TCP port 22.

327
00:22:48,070 --> 00:22:55,070
Telnet, which can also be used to connect
to the CLI of devices, uses TCP port 23.

328
00:22:55,070 --> 00:23:02,740
SMTP, the Simple Mail Transfer Protocol, is
used for sending email and uses TCP port 25.

329
00:23:02,740 --> 00:23:09,510
HTTP, Hypertext Transfer Protocol, commonly
used for accessing web pages, uses TCP port

330
00:23:09,510 --> 00:23:10,810
80.

331
00:23:10,810 --> 00:23:18,210
POP3, Post Office Protocol 3, used for retrieving
emails, uses TCP port 110.

332
00:23:18,210 --> 00:23:24,830
And finally HTTPS, Hypertext Transfer Protocol
Secure, uses TCP port 443.

333
00:23:24,830 --> 00:23:28,780
Okay, let’s list some protocols that use
UDP.

334
00:23:28,780 --> 00:23:34,680
DHCP, Dynamic Host Configuration Protocol,
which allows hosts to automatically set their

335
00:23:34,680 --> 00:23:40,070
IP address and other things, uses UDP ports
67 and 68.

336
00:23:40,070 --> 00:23:46,790
TFTP, the Trivial File Transfer Protocol,
uses UDP port 69.

337
00:23:46,790 --> 00:23:54,410
SNMP, the Simple Network Management Protocol,
uses UDP ports 161 and 162.

338
00:23:54,410 --> 00:23:57,670
Syslog uses UDP port 514.

339
00:23:57,670 --> 00:24:04,309
Finally, the only protocol you should be aware
of that uses both TCP and UDP is DNS, Domain

340
00:24:04,309 --> 00:24:05,950
Name System.

341
00:24:05,950 --> 00:24:10,820
It usually uses UDP, but uses TCP in some
situations.

342
00:24:10,820 --> 00:24:16,540
Okay, to help you review I have added a ‘portnumbers’
tag to the Anki flashcards for these port

343
00:24:16,550 --> 00:24:17,550
numbers.

344
00:24:17,550 --> 00:24:20,450
Here’s how you can use it to review these
specific cards.

345
00:24:20,450 --> 00:24:23,470
Open the Anki flashcard deck.

346
00:24:23,470 --> 00:24:25,200
Click on ‘custom study’.

347
00:24:25,200 --> 00:24:26,970
You’ll see this window.

348
00:24:26,970 --> 00:24:30,320
Select ‘study by card state or tag’.

349
00:24:30,320 --> 00:24:34,809
Then select ‘all cards in random order (don’t
reschedule)’.

350
00:24:34,809 --> 00:24:36,850
Finally click on ‘choose tags’.

351
00:24:36,850 --> 00:24:38,820
This window will pop up.

352
00:24:38,820 --> 00:24:43,000
Check ‘require one or more of these tags’
and make sure the ‘portnumbers’ tag is

353
00:24:43,000 --> 00:24:44,410
highlighted.

354
00:24:44,410 --> 00:24:48,150
Also make sure it isn’t highlighted under
‘select tags to exclude’.

355
00:24:48,150 --> 00:24:50,550
Finally, click OK.

356
00:24:50,550 --> 00:24:56,090
Now you will be able to review the cards without
effecting Anki’s scheduling algorithm.

357
00:24:56,090 --> 00:25:00,090
After you have reviewed them, you can simply
follow this same process again if you want

358
00:25:00,090 --> 00:25:02,130
to review them once more.

359
00:25:02,130 --> 00:25:05,120
Do it until you answer them all perfectly.

360
00:25:05,120 --> 00:25:10,050
By the way, if you have questions about Anki
on other platforms like iOS or Android, or

361
00:25:10,050 --> 00:25:14,770
are having trouble getting the custom study
session set up, please try a Google search

362
00:25:14,770 --> 00:25:16,370
or look on the Anki website.

363
00:25:16,370 --> 00:25:21,130
I’m no Anki expert and it’s hard for me
to troubleshoot Anki problems via the comment

364
00:25:21,130 --> 00:25:23,620
section.

365
00:25:23,620 --> 00:25:27,000
Before moving on to the quiz, let’s review
what we covered.

366
00:25:27,000 --> 00:25:33,040
We covered the basics of Layer 4, including
Layer 4 addressing in the form of port numbers.

367
00:25:33,040 --> 00:25:38,430
We took a look at TCP, a Layer 4 protocol
which provides various services to applications,

368
00:25:38,430 --> 00:25:42,070
such as reliable communication and flow control.

369
00:25:42,070 --> 00:25:46,950
Then we looked at UDP, which doesn’t provide
the various services that TCP does, but uses

370
00:25:46,950 --> 00:25:49,330
a smaller header with less overhead.

371
00:25:49,330 --> 00:25:53,550
Finally, we spent some time comparing the
two protocols.

372
00:25:53,550 --> 00:25:58,020
Remember the exam topics list, you’re expected
to be able to compare the two for the exam,

373
00:25:58,020 --> 00:25:59,920
so focus on that.

374
00:25:59,920 --> 00:26:04,309
Watch until the end of the quiz for a bonus
question from Boson ExSim, the best practice

375
00:26:04,309 --> 00:26:05,830
exams for the CCNA.

376
00:26:05,830 --> 00:26:10,890
Okay, let’s go to quiz question 1.

377
00:26:10,890 --> 00:26:15,190
Which of the following is a well-known port
number, as defined by IANA?

378
00:26:15,190 --> 00:26:17,440
A, 1010.

379
00:26:17,440 --> 00:26:19,690
B, 2001.

380
00:26:19,690 --> 00:26:21,940
C, 4023.

381
00:26:21,940 --> 00:26:24,500
Or D, 65000.

382
00:26:24,500 --> 00:26:30,170
Pause the video to think about your answer.

383
00:26:30,170 --> 00:26:33,020
The answer is A, 1010.

384
00:26:33,020 --> 00:26:35,690
Here are the ranges designated by IANA.

385
00:26:35,690 --> 00:26:40,420
Well-known port numbers are those from 0 through
1023.

386
00:26:40,420 --> 00:26:45,420
Answers B and C are in the Registered range,
and D is in the Ephemeral range.

387
00:26:45,420 --> 00:26:48,620
Okay, let’s move on to question 2.

388
00:26:48,620 --> 00:26:54,860
According to IANA specifications, what range
of port numbers should hosts select from when

389
00:26:54,860 --> 00:26:58,059
randomly selecting a source Layer 4 port number?

390
00:26:58,059 --> 00:26:59,500
A, well-known.

391
00:26:59,500 --> 00:27:00,930
B, registered.

392
00:27:00,930 --> 00:27:02,370
C, ephemeral.

393
00:27:02,370 --> 00:27:04,200
Or D, reserved.

394
00:27:04,200 --> 00:27:08,950
Pause the video to think about your answer.

395
00:27:08,950 --> 00:27:11,320
The answer is C, ephemeral.

396
00:27:11,320 --> 00:27:15,390
The destination port number depends on the
Application layer protocol, but the source

397
00:27:15,390 --> 00:27:19,200
port number should be randomly selected from
the Ephemeral port range.

398
00:27:19,200 --> 00:27:23,970
Once again, here are the different port ranges
as designated by IANA.

399
00:27:23,970 --> 00:27:26,990
Note that D, reserved, isn’t one of the
ranges.

400
00:27:26,990 --> 00:27:31,610
Okay, let’s go to question 3.

401
00:27:31,610 --> 00:27:35,050
Which of the following are features of TCP
but not UDP?

402
00:27:35,050 --> 00:27:36,460
(select three).

403
00:27:36,460 --> 00:27:38,940
A, Layer 4 addressing.

404
00:27:38,940 --> 00:27:41,210
B, error recovery.

405
00:27:41,210 --> 00:27:43,270
C, session multiplexing.

406
00:27:43,270 --> 00:27:45,630
D, flow control.

407
00:27:45,630 --> 00:27:47,630
And E, sequencing.

408
00:27:47,630 --> 00:27:54,660
Pause the video to think about your answers,
select three.

409
00:27:54,660 --> 00:28:00,970
The answers are B, error recovery, D, flow
control, and E, sequencing.

410
00:28:00,970 --> 00:28:05,520
Layer 4 addressing in the form of port numbers
and session multiplexing are features of both

411
00:28:05,520 --> 00:28:11,710
TCP and UDP, but only TCP provides services
like error recovery, flow control, and sequencing

412
00:28:11,710 --> 00:28:12,960
to applications.

413
00:28:12,960 --> 00:28:17,870
Okay, let’s go to question 4.

414
00:28:17,870 --> 00:28:22,860
Which of the following Application Layer protocols
use TCP to provide reliable communications?

415
00:28:22,860 --> 00:28:24,860
(select three).

416
00:28:24,860 --> 00:28:26,850
A, SMTP.

417
00:28:26,850 --> 00:28:28,840
B, SNMP.

418
00:28:28,840 --> 00:28:30,840
C, HTTPS.

419
00:28:30,840 --> 00:28:32,830
D, DHCP.

420
00:28:32,830 --> 00:28:34,830
E, Syslog.

421
00:28:34,830 --> 00:28:36,830
Or F, SSH.

422
00:28:36,830 --> 00:28:44,000
Pause the video to think about your answers,
select three.

423
00:28:44,000 --> 00:28:50,250
The answers are A, SMTP, C, HTTPS, and F,
SSH.

424
00:28:50,250 --> 00:28:53,610
Although we haven’t learned the details
of these protocols yet, I recommend learning

425
00:28:53,610 --> 00:28:57,020
which ones use TCP or UDP, and their port
numbers.

426
00:28:57,020 --> 00:28:59,710
You’ll definitely need to know some of them
for the test.

427
00:28:59,710 --> 00:29:03,559
Okay, let’s move on to question 5.

428
00:29:03,559 --> 00:29:08,160
PC1 and SRV1 have an active TCP connection.

429
00:29:08,160 --> 00:29:13,640
SRV1 receives a TCP segment from PC1 with
a sequence number of 27.

430
00:29:13,640 --> 00:29:18,260
When SRV1 acknowledges the segment, what will
the value of the Acknowledgment field in the

431
00:29:18,260 --> 00:29:19,440
TCP header be?

432
00:29:19,440 --> 00:29:22,280
Assume a TCP window size of 1.

433
00:29:22,280 --> 00:29:23,730
A, 26.

434
00:29:23,730 --> 00:29:25,190
B, 27.

435
00:29:25,190 --> 00:29:27,360
Or C, 28.

436
00:29:27,360 --> 00:29:32,970
Pause the video to think about your answer.

437
00:29:32,970 --> 00:29:38,580
The answer is C. TCP uses ‘forward acknowledgment’,
meaning it acknowledges that it received a

438
00:29:38,580 --> 00:29:43,330
segment by stating the next segment it expects
to receive.

439
00:29:43,330 --> 00:29:49,190
If SRV1 acknowledged with a value of 27, for
example, PC1 would assume that SRV1 didn’t

440
00:29:49,190 --> 00:29:53,020
receive the segment with sequence number 27,
so it would send it again.

441
00:29:53,020 --> 00:29:58,309
Don’t worry too much about the details of
TCP operations, but make sure you have a basic

442
00:29:58,309 --> 00:30:01,179
understanding of how sequencing and acknowledgment
works.

443
00:30:01,179 --> 00:30:03,300
Okay, that’s all for the quiz.

444
00:30:03,300 --> 00:30:09,630
Let’s take a look at a bonus question in
Boson ExSim for CCNA.

445
00:30:09,630 --> 00:30:11,740
Here's today's Boson ExSim practice question.

446
00:30:11,740 --> 00:30:17,559
So, I will click on Launch Simulator and here
it is, a drag-and-drop question.

447
00:30:17,559 --> 00:30:21,360
Select the applications layer protocols on
the left, and drag them to the corresponding

448
00:30:21,360 --> 00:30:23,350
transport layer protocols.

449
00:30:23,350 --> 00:30:25,760
All application layer protocols will be used.

450
00:30:25,760 --> 00:30:30,290
So, these here on the left are all application
layer protocols, and these are the transport

451
00:30:30,290 --> 00:30:33,270
layer protocols we just learned, TCP and UDP.

452
00:30:33,270 --> 00:30:36,670
And also one of these uses both TCP and UDP.

453
00:30:36,670 --> 00:30:43,980
Okay, so pause the video here and think about
the answer.

454
00:30:43,980 --> 00:30:45,440
Okay, let's check.

455
00:30:45,450 --> 00:30:47,570
So I will go from top to bottom.

456
00:30:47,570 --> 00:30:52,520
DNS, Domain Name System, that uses TCP and
UDP.

457
00:30:52,520 --> 00:30:57,640
Usually it uses UDP, but it does use TCP in
some cases.

458
00:30:57,640 --> 00:31:00,330
Next, DHCP uses UDP.

459
00:31:00,330 --> 00:31:04,460
FTP, File Transfer Protocol, TCP.

460
00:31:04,460 --> 00:31:08,210
HTTP uses TCP.

461
00:31:08,210 --> 00:31:13,140
SMTP, Simple Mail Transfer Protocol, TCP.

462
00:31:13,140 --> 00:31:15,730
And then these last two, of course UDP.

463
00:31:15,730 --> 00:31:19,270
SNMP, Simple Network Management Protocol.

464
00:31:19,270 --> 00:31:22,570
And TFTP, the Trivial File Transfer Protocol.

465
00:31:22,570 --> 00:31:26,380
Okay, so I will click on 'done'.

466
00:31:26,380 --> 00:31:27,710
And let's see if I'm correct.

467
00:31:27,710 --> 00:31:29,490
Click on 'show answer'.

468
00:31:29,490 --> 00:31:32,040
And yes, that is correct.

469
00:31:32,040 --> 00:31:38,720
So, if you want to read Boson's explanation
you can pause the video here.

470
00:31:38,720 --> 00:31:43,090
I haven't explained all of these application
layer protocols yet, but I will cover them

471
00:31:43,090 --> 00:31:44,799
later in the course.

472
00:31:44,799 --> 00:31:51,299
For now just remember whether they use TCP
or UDP, and also remember their port numbers.

473
00:31:51,299 --> 00:31:55,910
Okay, so that's Boson ExSim for CCNA.

474
00:31:55,910 --> 00:31:57,540
I highly recommend these practice exams.

475
00:31:57,540 --> 00:32:03,260
I used them when I was studying for my CCNA
and CCNP exams, and I highly recommend them

476
00:32:03,260 --> 00:32:05,850
because they really helped me pass my exams.

477
00:32:05,850 --> 00:32:13,290
So, if you want to get a copy of Boson ExSim,
please follow the link in the video description.

478
00:32:13,290 --> 00:32:16,480
There are supplementary materials for this
video.

479
00:32:16,480 --> 00:32:19,870
There is a flashcard deck to use with the
software ‘Anki’.

480
00:32:19,870 --> 00:32:23,970
This time there won’t be a packet tracer
practice lab, instead I will make a Wireshark

481
00:32:23,970 --> 00:32:28,880
demo, to show you TCP and UDP in action in
a real network.

482
00:32:28,880 --> 00:32:33,250
Wireshark is a packet capture program, which
lets you analyze network traffic.

483
00:32:33,250 --> 00:32:39,440
It’s great for studying and also a very
useful tool for network engineers.

484
00:32:39,440 --> 00:32:43,230
Before finishing today’s video I want to
thank my JCNP-level channel members.

485
00:32:43,230 --> 00:32:47,500
To join, please click the ‘Join’ button
under the video.

486
00:32:47,500 --> 00:32:53,240
Thank you to Benjamin, Deepak, Tshepiso, Justin,
Loki, TheGunguy, Nil, Alex, Prakaash, Nasir,

487
00:32:53,240 --> 00:32:59,330
Erlison, Apogee, Wasseem, Marko, Florian,
Daming, Kone, Joshua, Jhilmar, Samil, Ed,

488
00:32:59,330 --> 00:33:05,980
Value, John, Funnydart, Scott, Hassan, Gerrard,
Joyce, Marek, Velvijaykum, C Mohd, Johan,

489
00:33:05,980 --> 00:33:11,840
Mark, Yousif, Sidi, Boson Software, Charlesetta,
Devin, Lito, Yonatan, and Vance.

490
00:33:11,840 --> 00:33:17,530
Sorry if I pronounced your name incorrectly,
but thank you so much for your support.

491
00:33:17,530 --> 00:33:21,330
One of you is still displaying as Channel
failed to load, if this is you please let

492
00:33:21,330 --> 00:33:24,410
me know and I’ll see if YouTube can fix
it.

493
00:33:24,410 --> 00:33:29,059
This is the list of JCNP-level members at
the time of recording by the way, September

494
00:33:29,059 --> 00:33:33,860
28th 2020, if you signed up recently and your
name isn’t on here don’t worry, you’ll

495
00:33:33,860 --> 00:33:37,480
be in future videos.

496
00:33:37,480 --> 00:33:39,059
Thank you for watching.

497
00:33:39,059 --> 00:33:43,030
Please subscribe to the channel, like the
video, leave a comment, and share the video

498
00:33:43,030 --> 00:33:46,299
with anyone else studying for the CCNA.

499
00:33:46,299 --> 00:33:48,890
If you want to leave a tip, check the links
in the description.

500
00:33:48,890 --> 00:33:55,180
I'm also a Brave verified publisher and accept
BAT, or Basic Attention Token, tips via the

501
00:33:55,180 --> 00:33:56,640
Brave browser.

502
00:33:56,640 --> 00:33:57,620
That's all for now.