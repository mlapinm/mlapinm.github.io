


<div class="grid"></div>

<div class="test">test</div>
<div>Score: <span id="score">0</span></div>



.grid{
  height: 160px;
  width: 160px;
  display: flex;
  flex-wrap: wrap;
  border: 1px solid
}

.grid div {
  height: 20px;
  width: 20px;
  background-color: lightgray;
  //border: thin solid;
}

document.addEventListener('DOMContentLoaded', () => {
  const test = document.querySelector('.test')
  const grid = document.querySelector('.grid')
  const scoreDisplay = document.querySelector('#score')
  
  const width = 8
  const ww = 8*8
  let squares = [] 
  const candyColors = ['red', 'yellow', 'orange', 
                      'purple', 'pink', 'blue']
  
  let score = 0
  
  function getNum(id){
    return id.substring(1)
  }
    
  function createBoard(){
    for(let i=0; i<ww; i++){
      const square = document.createElement('div')
      square.setAttribute('draggable', true)
      square.setAttribute('id', 'g' + i)
      let randomColor = Math.floor(Math.random() * candyColors.length)
      square.style.backgroundColor = candyColors[randomColor]
      
      grid.appendChild(square)
      squares.push(square)
      // square.innerText=i
      
    }
  }
  
  createBoard()
  
  // Drag the candies
  let colorBeingDragged
  let colorBeingReplaced
  let squareIdBeingDragged
  let squareIdBeingReplaced
  
  squares.forEach( square => square.addEventListener('dragstart', dragStart))
  squares.forEach( square => square.addEventListener('dragend', dragEnd))
  squares.forEach( square => square.addEventListener('dragover', dragOver))
  squares.forEach( square => square.addEventListener('dragenter', dragEnter))
  squares.forEach( square => square.addEventListener('dragleave', dragLeave))
  squares.forEach( square => square.addEventListener('drop', dragDrop))
  squares.forEach( square => square.addEventListener('touchstart', touchStart))
  squares.forEach( square => square.addEventListener('touchmove', touchMove))
  squares.forEach( square => square.addEventListener('touchend', touchEnd))
    
  
  function touchStart(e){
    squareIdBeingDragged = getNum(this.id)
    colorBeingDragged = this.style.backgroundColor
  }
  
  function touchMove(e){
    e.preventDefault()
  }
  

  function dragStart(){
    colorBeingDragged = this.style.backgroundColor
    squareIdBeingDragged = parseInt(getNum(this.id))
  }
  
  function dragOver(e){
    e.preventDefault()
    
  }
  
  function dragEnter(e){
    e.preventDefault()
    
  }
  
  function dragLeave(){
    
  }
  
    function dragDrop(){
    colorBeingReplaced = this.style.backgroundColor
    squareIdBeingReplaced = parseInt(getNum(this.id))
  }

  
    function moveEnd(){
      let validMovies = [squareIdBeingDragged -1, squareIdBeingDragged - width, 
                         squareIdBeingDragged +1, squareIdBeingDragged + width]
      
      let validMove  = validMovies.includes(squareIdBeingReplaced)
      
      if(validMove){
      squares[squareIdBeingDragged].style.backgroundColor = colorBeingReplaced
      squares[squareIdBeingReplaced].style.backgroundColor = colorBeingDragged
      }
    }
  
    function touchEnd(e){
    var changedTouch = e.changedTouches[0];
    var elem = document.elementFromPoint(changedTouch.clientX, changedTouch.clientY);
    colorBeingReplaced = elem.style.backgroundColor
    squareIdBeingReplaced = parseInt(getNum(elem.id))
      
    moveEnd()
  }

  
  
    function dragEnd(){
 
    moveEnd()
  
  }
  
  function checkRowsForLine(lineLength){
    let notValid = []
    for(i = 0; i < ww; i++){
      if(i%width == 0){
        for(j = 0; j < lineLength -1; j++){
          notValid.push(i+j)
        }
      }
    }
    for(i = 0; i < ww - lineLength; i++){
      let rowOfLine = []
      for (j = 0; j < lineLength; j++){
        rowOfLine.push(i+j)
      }
      let decidedColor = squares[i+lineLength-1].style.backgroundColor
      const isBlank = squares[i].style.backgroundColor === 'white'
      
      if(notValid.includes(i+lineLength-1)) continue
      
      if(rowOfLine.every(index => squares[index].style.backgroundColor 
                         === decidedColor && !isBlank)) {
        score += lineLength
        scoreDisplay.innerText = score
        
        rowOfLine.forEach(index => {
          squares[index].style.backgroundColor = 'white'
        })
      }
    }
  }
  
  function checkColumnForLine(lineLength){
    for (i = 0; i <  ww - width*(lineLength - 1) -1; i++){
      let columnOfLine = []
      for(j = 0; j < lineLength; j++){
        columnOfLine.push(i+j*width)
      }
      let decidedColor = squares[i].style.backgroundColor
      
      const isBlank = squares[i].style.backgroundColor === 'white'
      
      if(columnOfLine.every(index => squares[index].style.backgroundColor
                           === decidedColor && !isBlank)){
        score += lineLength
        scoreDisplay.innerText = score
        
        columnOfLine.forEach(index =>{
          squares[index].style.backgroundColor = 'white'
        })
      }
    }
  }
  
  function moveIntoSquareBelow(){
    let firstRow = []
    for(let i=0;i < width;i++){
      firstRow.push(i)
    }
    
    for(let i=0;i < ww-width;i++){
      if(squares[i + width].style.backgroundColor === 'white'){
        squares[i + width].style.backgroundColor =
        squares[i].style.backgroundColor
        squares[i].style.backgroundColor = 'white'
        
        const isFistRow = firstRow.includes(i)
     if(isFistRow && (squares[i].style.backgroundColor === 'white')){
          let randomColor = Math.floor(Math.random()*candyColors.length)
       test.innerText = randomColor
          squares[i].style.backgroundColor = candyColors[randomColor]
        }
        
      }
      
    }
  }
  
  
  
  window.setInterval(() => {
      for(let i=width-1;i>=3;i--){
        checkRowsForLine(i)
        checkColumnForLine(i)
    
      }
     moveIntoSquareBelow()
     

}, 100)
  
  
  
})

